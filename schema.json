{
    "name": "awsx",
    "displayName": "AWSx (Pulumi Crosswalk for AWS)",
    "description": "Pulumi Amazon Web Services (AWS) AWSX Components.",
    "keywords": [
        "pulumi",
        "aws",
        "awsx",
        "kind/component",
        "category/cloud"
    ],
    "homepage": "https://pulumi.com",
    "license": "Apache-2.0",
    "repository": "https://github.com/pulumi/pulumi-awsx",
    "publisher": "Pulumi",
    "language": {
        "csharp": {
            "liftSingleValueMethodReturns": true,
            "packageReferences": {
                "Pulumi": "3.*",
                "Pulumi.Aws": "6.*",
                "Pulumi.Docker": "4.*"
            }
        },
        "go": {
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-awsx/sdk/v2/go/awsx",
            "internalDependencies": [
                "github.com/pulumi/pulumi-docker/sdk/v4/go/docker"
            ],
            "liftSingleValueMethodReturns": true
        },
        "java": {
            "dependencies": {
                "com.pulumi:aws": "6.32.0",
                "com.pulumi:docker": "4.5.1"
            }
        },
        "nodejs": {
            "dependencies": {
                "@aws-sdk/client-ecs": "^3.405.0",
                "@pulumi/aws": "^6.32.0",
                "@pulumi/docker": "^4.5.1",
                "@pulumi/pulumi": "^3.0.0",
                "@types/aws-lambda": "^8.10.23",
                "aws-sdk": "^2.1450.0",
                "docker-classic": "npm:@pulumi/docker@3.6.1",
                "mime": "^2.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^18",
                "typescript": "^4.6.2"
            }
        },
        "python": {
            "liftSingleValueMethodReturns": true,
            "pyproject": {
                "enabled": true
            },
            "readme": "Pulumi Amazon Web Services (AWS) AWSX Components.",
            "requires": {
                "pulumi": "\u003e=3.91.1,\u003c4.0.0",
                "pulumi-aws": "\u003e=6.0.4,\u003c7.0.0",
                "pulumi-docker": "\u003e=4.5.1,\u003c5.0.0"
            },
            "usesIOClasses": true
        }
    },
    "config": {},
    "types": {
        "awsx:awsx:Bucket": {
            "description": "The set of arguments for constructing a Bucket resource.",
            "properties": {
                "accelerationStatus": {
                    "type": "string",
                    "description": "Sets the accelerate configuration of an existing bucket. Can be `Enabled` or `Suspended`.\n"
                },
                "acl": {
                    "type": "string",
                    "description": "The [canned ACL](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl) to apply. Valid values are `private`, `public-read`, `public-read-write`, `aws-exec-read`, `authenticated-read`, and `log-delivery-write`. Defaults to `private`.  Conflicts with `grant`.\n"
                },
                "arn": {
                    "type": "string",
                    "description": "The ARN of the bucket. Will be of format `arn:aws:s3:::bucketname`.\n"
                },
                "bucket": {
                    "type": "string",
                    "description": "The name of the bucket. If omitted, this provider will assign a random, unique name. Must be lowercase and less than or equal to 63 characters in length. A full list of bucket naming rules [may be found here](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html).\n",
                    "language": {
                        "csharp": {
                            "name": "BucketName"
                        }
                    },
                    "willReplaceOnChanges": true
                },
                "bucketPrefix": {
                    "type": "string",
                    "description": "Creates a unique bucket name beginning with the specified prefix. Conflicts with `bucket`. Must be lowercase and less than or equal to 37 characters in length. A full list of bucket naming rules [may be found here](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucketnamingrules.html).\n",
                    "willReplaceOnChanges": true
                },
                "corsRules": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketCorsRule:BucketCorsRule"
                    },
                    "description": "A rule of [Cross-Origin Resource Sharing](https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html) (documented below).\n"
                },
                "forceDestroy": {
                    "type": "boolean",
                    "description": "A boolean that indicates all objects (including any [locked objects](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock-overview.html)) should be deleted from the bucket so that the bucket can be destroyed without error. These objects are *not* recoverable.\n"
                },
                "grants": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketGrant:BucketGrant"
                    },
                    "description": "An [ACL policy grant](https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#sample-acl) (documented below). Conflicts with `acl`.\n"
                },
                "hostedZoneId": {
                    "type": "string",
                    "description": "The [Route 53 Hosted Zone ID](https://docs.aws.amazon.com/general/latest/gr/rande.html#s3_website_region_endpoints) for this bucket's region.\n"
                },
                "lifecycleRules": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketLifecycleRule:BucketLifecycleRule"
                    },
                    "description": "A configuration of [object lifecycle management](http://docs.aws.amazon.com/AmazonS3/latest/dev/object-lifecycle-mgmt.html) (documented below).\n"
                },
                "loggings": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketLogging:BucketLogging"
                    },
                    "description": "A settings of [bucket logging](https://docs.aws.amazon.com/AmazonS3/latest/UG/ManagingBucketLogging.html) (documented below).\n"
                },
                "objectLockConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketObjectLockConfiguration:BucketObjectLockConfiguration",
                    "description": "A configuration of [S3 object locking](https://docs.aws.amazon.com/AmazonS3/latest/dev/object-lock.html) (documented below)\n\n\u003e **NOTE:** You cannot use `acceleration_status` in `cn-north-1` or `us-gov-west-1`\n"
                },
                "policy": {
                    "type": "string",
                    "description": "A valid [bucket policy](https://docs.aws.amazon.com/AmazonS3/latest/dev/example-bucket-policies.html) JSON document. Note that if the policy document is not specific enough (but still valid), this provider may view the policy as constantly changing in a `pulumi preview`. In this case, please make sure you use the verbose/specific version of the policy.\n"
                },
                "replicationConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketReplicationConfiguration:BucketReplicationConfiguration",
                    "description": "A configuration of [replication configuration](http://docs.aws.amazon.com/AmazonS3/latest/dev/crr.html) (documented below).\n"
                },
                "requestPayer": {
                    "type": "string",
                    "description": "Specifies who should bear the cost of Amazon S3 data transfer.\nCan be either `BucketOwner` or `Requester`. By default, the owner of the S3 bucket would incur\nthe costs of any data transfer. See [Requester Pays Buckets](http://docs.aws.amazon.com/AmazonS3/latest/dev/RequesterPaysBuckets.html)\ndeveloper guide for more information.\n"
                },
                "serverSideEncryptionConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketServerSideEncryptionConfiguration:BucketServerSideEncryptionConfiguration",
                    "description": "A configuration of [server-side encryption configuration](http://docs.aws.amazon.com/AmazonS3/latest/dev/bucket-encryption.html) (documented below)\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the bucket. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "versioning": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketVersioning:BucketVersioning",
                    "description": "A state of [versioning](https://docs.aws.amazon.com/AmazonS3/latest/dev/Versioning.html) (documented below)\n"
                },
                "website": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:s3/BucketWebsite:BucketWebsite",
                    "description": "A website object (documented below).\n"
                },
                "websiteDomain": {
                    "type": "string",
                    "description": "The domain of the website endpoint, if the bucket is configured with a website. If not, this will be an empty string. This is used to create Route 53 alias records.\n"
                },
                "websiteEndpoint": {
                    "type": "string",
                    "description": "The website endpoint, if the bucket is configured with a website. If not, this will be an empty string.\n"
                }
            },
            "type": "object"
        },
        "awsx:awsx:DefaultBucket": {
            "description": "Bucket with default setup unless explicitly skipped.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:Bucket",
                    "plain": true,
                    "description": "Arguments to use instead of the default values during creation."
                },
                "existing": {
                    "$ref": "#/types/awsx:awsx:ExistingBucket",
                    "plain": true,
                    "description": "Identity of an existing bucket to use. Cannot be used in combination with `args`."
                },
                "skip": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Skip creation of the bucket."
                }
            },
            "type": "object"
        },
        "awsx:awsx:DefaultLogGroup": {
            "description": "Log group with default setup unless explicitly skipped.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:LogGroup",
                    "plain": true,
                    "description": "Arguments to use instead of the default values during creation."
                },
                "existing": {
                    "$ref": "#/types/awsx:awsx:ExistingLogGroup",
                    "plain": true,
                    "description": "Identity of an existing log group to use. Cannot be used in combination with `args` or `opts`."
                },
                "skip": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Skip creation of the log group."
                }
            },
            "type": "object"
        },
        "awsx:awsx:DefaultRoleWithPolicy": {
            "description": "Role and policy attachments with default setup unless explicitly skipped or an existing role ARN provided.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:RoleWithPolicy",
                    "plain": true,
                    "description": "Args to use when creating the role and policies. Can't be specified if `roleArn` is used."
                },
                "roleArn": {
                    "type": "string",
                    "description": "ARN of existing role to use instead of creating a new role. Cannot be used in combination with `args` or `opts`."
                },
                "skip": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Skips creation of the role if set to `true`."
                }
            },
            "type": "object"
        },
        "awsx:awsx:DefaultSecurityGroup": {
            "description": "Security Group with default setup unless explicitly skipped or an existing security group id provided.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:SecurityGroup",
                    "plain": true,
                    "description": "Args to use when creating the security group. Can't be specified if `securityGroupId` is used."
                },
                "securityGroupId": {
                    "type": "string",
                    "description": "Id of existing security group to use instead of creating a new security group. Cannot be used in combination with `args` or `opts`."
                },
                "skip": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Skips creation of the security group if set to `true`."
                }
            },
            "type": "object"
        },
        "awsx:awsx:ExistingBucket": {
            "description": "Reference to an existing bucket.",
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "Arn of the bucket. Only one of [arn] or [name] can be specified."
                },
                "name": {
                    "type": "string",
                    "description": "Name of the bucket. Only one of [arn] or [name] can be specified."
                }
            },
            "type": "object"
        },
        "awsx:awsx:ExistingLogGroup": {
            "description": "Reference to an existing log group.",
            "properties": {
                "arn": {
                    "type": "string",
                    "description": "Arn of the log group. Only one of [arn] or [name] can be specified."
                },
                "name": {
                    "type": "string",
                    "description": "Name of the log group. Only one of [arn] or [name] can be specified."
                },
                "region": {
                    "type": "string",
                    "description": "Region of the log group. If not specified, the provider region will be used."
                }
            },
            "type": "object"
        },
        "awsx:awsx:LogGroup": {
            "description": "The set of arguments for constructing a LogGroup resource.",
            "properties": {
                "kmsKeyId": {
                    "type": "string",
                    "description": "The ARN of the KMS Key to use when encrypting log data. Please note, after the AWS KMS CMK is disassociated from the log group,\nAWS CloudWatch Logs stops encrypting newly ingested data for the log group. All previously ingested data remains encrypted, and AWS CloudWatch Logs requires\npermissions for the CMK whenever the encrypted data is requested.\n"
                },
                "logGroupClass": {
                    "type": "string",
                    "description": "Specified the log class of the log group. Possible values are: `STANDARD` or `INFREQUENT_ACCESS`.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the log group. If omitted, this provider will assign a random, unique name.\n",
                    "willReplaceOnChanges": true
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique name beginning with the specified prefix. Conflicts with `name`.\n",
                    "willReplaceOnChanges": true
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "Specifies the number of days\nyou want to retain log events in the specified log group.  Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1096, 1827, 2192, 2557, 2922, 3288, 3653, and 0.\nIf you select 0, the events in the log group are always retained and never expire.\n"
                },
                "skipDestroy": {
                    "type": "boolean",
                    "description": "Set to true if you do not wish the log group (and any logs it may contain) to be deleted at destroy time, and instead just remove the log group from the state.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                }
            },
            "type": "object"
        },
        "awsx:awsx:OptionalLogGroup": {
            "description": "Log group which is only created if enabled.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:LogGroup",
                    "plain": true,
                    "description": "Arguments to use instead of the default values during creation."
                },
                "enable": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Enable creation of the log group."
                },
                "existing": {
                    "$ref": "#/types/awsx:awsx:ExistingLogGroup",
                    "plain": true,
                    "description": "Identity of an existing log group to use. Cannot be used in combination with `args` or `opts`."
                }
            },
            "type": "object"
        },
        "awsx:awsx:RequiredBucket": {
            "description": "Bucket with default setup.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:Bucket",
                    "plain": true,
                    "description": "Arguments to use instead of the default values during creation."
                },
                "existing": {
                    "$ref": "#/types/awsx:awsx:ExistingBucket",
                    "plain": true,
                    "description": "Identity of an existing bucket to use. Cannot be used in combination with `args`."
                }
            },
            "type": "object"
        },
        "awsx:awsx:RequiredLogGroup": {
            "description": "Log group with default setup.",
            "properties": {
                "args": {
                    "$ref": "#/types/awsx:awsx:LogGroup",
                    "plain": true,
                    "description": "Arguments to use instead of the default values during creation."
                },
                "existing": {
                    "$ref": "#/types/awsx:awsx:ExistingLogGroup",
                    "plain": true,
                    "description": "Identity of an existing log group to use. Cannot be used in combination with `args` or `opts`."
                }
            },
            "type": "object"
        },
        "awsx:awsx:RoleWithPolicy": {
            "description": "The set of arguments for constructing a Role resource and Policy attachments.",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Description of the role.\n"
                },
                "forceDetachPolicies": {
                    "type": "boolean",
                    "description": "Whether to force detaching any policies the role has before destroying it. Defaults to `false`.\n"
                },
                "inlinePolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:iam/RoleInlinePolicy:RoleInlinePolicy"
                    },
                    "description": "Configuration block defining an exclusive set of IAM inline policies associated with the IAM role. See below. If no blocks are configured, the provider will not manage any inline policies in this resource. Configuring one empty block (i.e., `inline_policy {}`) will cause the provider to remove _all_ inline policies added out of band on `apply`.\n"
                },
                "managedPolicyArns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "maxSessionDuration": {
                    "type": "integer",
                    "description": "Maximum session duration (in seconds) that you want to set for the specified role. If you do not specify a value for this setting, the default maximum of one hour is applied. This setting can have a value from 1 hour to 12 hours.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Friendly name of the role. If omitted, the provider will assign a random, unique name. See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) for more information.\n",
                    "willReplaceOnChanges": true
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique friendly name beginning with the specified prefix. Conflicts with `name`.\n",
                    "willReplaceOnChanges": true
                },
                "path": {
                    "type": "string",
                    "description": "Path to the role. See [IAM Identifiers](https://docs.aws.amazon.com/IAM/latest/UserGuide/Using_Identifiers.html) for more information.\n",
                    "willReplaceOnChanges": true
                },
                "permissionsBoundary": {
                    "type": "string",
                    "description": "ARN of the policy that is used to set the permissions boundary for the role.\n"
                },
                "policyArns": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "plain": true
                    },
                    "plain": true,
                    "description": "ARNs of the policies to attach to the created role."
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value mapping of tags for the IAM role. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                }
            },
            "type": "object"
        },
        "awsx:awsx:SecurityGroup": {
            "description": "The set of arguments for constructing a Security Group resource.",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Security group description. Defaults to `Managed by Pulumi`. Cannot be `\"\"`. **NOTE**: This field maps to the AWS `GroupDescription` attribute, for which there is no Update API. If you'd like to classify your security groups in a way that can be updated, use `tags`.\n",
                    "default": "Managed by Pulumi",
                    "willReplaceOnChanges": true
                },
                "egress": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ec2/SecurityGroupEgress:SecurityGroupEgress"
                    },
                    "description": "Configuration block for egress rules. Can be specified multiple times for each egress rule. Each egress block supports fields documented below. This argument is processed in attribute-as-blocks mode.\n"
                },
                "ingress": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ec2/SecurityGroupIngress:SecurityGroupIngress"
                    },
                    "description": "Configuration block for ingress rules. Can be specified multiple times for each ingress rule. Each ingress block supports fields documented below. This argument is processed in attribute-as-blocks mode.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the security group. If omitted, the provider will assign a random, unique name.\n",
                    "willReplaceOnChanges": true
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique name beginning with the specified prefix. Conflicts with `name`.\n",
                    "willReplaceOnChanges": true
                },
                "revokeRulesOnDelete": {
                    "type": "boolean",
                    "description": "Instruct the provider to revoke all of the Security Groups attached ingress and egress rules before deleting the rule itself. This is normally not needed, however certain AWS services such as Elastic Map Reduce may automatically add required rules to security groups used with the service, and those rules may contain a cyclic dependency that prevent the security groups from being destroyed without removing the dependency first. Default `false`.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "vpcId": {
                    "type": "string",
                    "description": "VPC ID. Defaults to the region's default VPC.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "awsx:cloudtrail:LogGroup": {
            "description": "Defines the log group configuration for the CloudWatch Log Group to send logs to.",
            "properties": {
                "kmsKeyId": {
                    "type": "string",
                    "description": "The ARN of the KMS Key to use when encrypting log data."
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique name beginning with the specified prefix"
                },
                "retentionInDays": {
                    "type": "integer",
                    "description": "Specifies the number of days you want to retain log events in the specified log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653, and 0. If you select 0, the events in the log group are always retained and never expire."
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource. If configured with provider defaultTags present, tags with matching keys will overwrite those defined at the provider-level."
                }
            },
            "type": "object"
        },
        "awsx:ec2:NatGatewayConfiguration": {
            "description": "Configuration for NAT Gateways.",
            "properties": {
                "elasticIpAllocationIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "plain": true,
                    "description": "A list of EIP allocation IDs to assign to the NAT Gateways. Optional. If specified, the number of supplied values must match the chosen strategy (either one, or the number of availability zones)."
                },
                "strategy": {
                    "$ref": "#/types/awsx:ec2:NatGatewayStrategy",
                    "plain": true,
                    "description": "The strategy for deploying NAT Gateways."
                }
            },
            "type": "object",
            "required": [
                "strategy"
            ]
        },
        "awsx:ec2:NatGatewayStrategy": {
            "description": "A strategy for creating NAT Gateways for private subnets within a VPC.",
            "type": "string",
            "enum": [
                {
                    "description": "Do not create any NAT Gateways. Resources in private subnets will not be able to access the internet.",
                    "value": "None"
                },
                {
                    "description": "Create a single NAT Gateway for the entire VPC. This configuration is not recommended for production infrastructure as it creates a single point of failure.",
                    "value": "Single"
                },
                {
                    "description": "Create a NAT Gateway in each availability zone. This is the recommended configuration for production infrastructure.",
                    "value": "OnePerAz"
                }
            ]
        },
        "awsx:ec2:ResolvedSubnetSpec": {
            "description": "Configuration for a VPC subnet spec.",
            "properties": {
                "cidrBlocks": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "plain": true
                    },
                    "plain": true,
                    "description": "An optional list of CIDR blocks to assign to the subnet spec for each AZ. If specified, the count must match the number of AZs being used for the VPC, and must also be specified for all other subnet specs."
                },
                "cidrMask": {
                    "type": "integer",
                    "plain": true,
                    "description": "The netmask for the subnet's CIDR block. This is optional, the default value is inferred from the `cidrMask`, `cidrBlocks` or based on an even distribution of available space from the VPC's CIDR block after being divided evenly by availability zone."
                },
                "name": {
                    "type": "string",
                    "plain": true,
                    "description": "The subnet's name. Will be templated upon creation."
                },
                "size": {
                    "type": "integer",
                    "plain": true,
                    "description": "Optional size of the subnet's CIDR block - the number of hosts. This value must be a power of 2 (e.g. 256, 512, 1024, etc.). This is optional, the default value is inferred from the `cidrMask`, `cidrBlocks` or based on an even distribution of available space from the VPC's CIDR block after being divided evenly by availability zone."
                },
                "type": {
                    "$ref": "#/types/awsx:ec2:SubnetType",
                    "plain": true,
                    "description": "The type of subnet."
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "awsx:ec2:SubnetAllocationStrategy": {
            "description": "Strategy for calculating subnet ranges from the subnet specifications.",
            "type": "string",
            "enum": [
                {
                    "description": "Group private subnets first, followed by public subnets, followed by isolated subnets.",
                    "value": "Legacy"
                },
                {
                    "description": "Order remains as specified by specs, allowing gaps where required.",
                    "value": "Auto"
                },
                {
                    "description": "Whole range of VPC must be accounted for, using \"Unused\" spec types for deliberate gaps.",
                    "value": "Exact"
                }
            ]
        },
        "awsx:ec2:SubnetSpec": {
            "description": "Configuration for a VPC subnet.",
            "properties": {
                "cidrBlocks": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "plain": true
                    },
                    "plain": true,
                    "description": "An optional list of CIDR blocks to assign to the subnet spec for each AZ. If specified, the count must match the number of AZs being used for the VPC, and must also be specified for all other subnet specs."
                },
                "cidrMask": {
                    "type": "integer",
                    "plain": true,
                    "description": "The netmask for the subnet's CIDR block. This is optional, the default value is inferred from the `cidrMask`, `cidrBlocks` or based on an even distribution of available space from the VPC's CIDR block after being divided evenly by availability zone."
                },
                "name": {
                    "type": "string",
                    "plain": true,
                    "description": "The subnet's name. Will be templated upon creation."
                },
                "size": {
                    "type": "integer",
                    "plain": true,
                    "description": "Optional size of the subnet's CIDR block - the number of hosts. This value must be a power of 2 (e.g. 256, 512, 1024, etc.). This is optional, the default value is inferred from the `cidrMask`, `cidrBlocks` or based on an even distribution of available space from the VPC's CIDR block after being divided evenly by availability zone."
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource."
                },
                "type": {
                    "$ref": "#/types/awsx:ec2:SubnetType",
                    "plain": true,
                    "description": "The type of subnet."
                }
            },
            "type": "object",
            "required": [
                "type"
            ]
        },
        "awsx:ec2:SubnetType": {
            "description": "A type of subnet within a VPC.",
            "type": "string",
            "enum": [
                {
                    "description": "A subnet whose hosts can directly communicate with the internet.",
                    "value": "Public"
                },
                {
                    "description": "A subnet whose hosts can not directly communicate with the internet, but can initiate outbound network traffic via a NAT Gateway.",
                    "value": "Private"
                },
                {
                    "description": "A subnet whose hosts have no connectivity with the internet.",
                    "value": "Isolated"
                },
                {
                    "description": "A subnet range which is reserved, but no subnet will be created.",
                    "value": "Unused"
                }
            ]
        },
        "awsx:ec2:VpcEndpointSpec": {
            "description": "Provides a VPC Endpoint resource.\n\n\u003e **NOTE on VPC Endpoints and VPC Endpoint Associations:** The provider provides both standalone VPC Endpoint Associations for\nRoute Tables - (an association between a VPC endpoint and a single `route_table_id`),\nSecurity Groups - (an association between a VPC endpoint and a single `security_group_id`),\nand Subnets - (an association between a VPC endpoint and a single `subnet_id`) and\na VPC Endpoint resource with `route_table_ids` and `subnet_ids` attributes.\nDo not use the same resource ID in both a VPC Endpoint resource and a VPC Endpoint Association resource.\nDoing so will cause a conflict of associations and will overwrite the association.\n\n## Example Usage\n\n### Basic\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst s3 = new aws.ec2.VpcEndpoint(\"s3\", {\n    vpcId: main.id,\n    serviceName: \"com.amazonaws.us-west-2.s3\",\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\ns3 = aws.ec2.VpcEndpoint(\"s3\",\n    vpc_id=main[\"id\"],\n    service_name=\"com.amazonaws.us-west-2.s3\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var s3 = new Aws.Ec2.VpcEndpoint(\"s3\", new()\n    {\n        VpcId = main.Id,\n        ServiceName = \"com.amazonaws.us-west-2.s3\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ec2.NewVpcEndpoint(ctx, \"s3\", \u0026ec2.VpcEndpointArgs{\n\t\t\tVpcId:       pulumi.Any(main.Id),\n\t\t\tServiceName: pulumi.String(\"com.amazonaws.us-west-2.s3\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ec2.VpcEndpoint;\nimport com.pulumi.aws.ec2.VpcEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var s3 = new VpcEndpoint(\"s3\", VpcEndpointArgs.builder()        \n            .vpcId(main.id())\n            .serviceName(\"com.amazonaws.us-west-2.s3\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  s3:\n    type: aws:ec2:VpcEndpoint\n    properties:\n      vpcId: ${main.id}\n      serviceName: com.amazonaws.us-west-2.s3\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Basic w/ Tags\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst s3 = new aws.ec2.VpcEndpoint(\"s3\", {\n    vpcId: main.id,\n    serviceName: \"com.amazonaws.us-west-2.s3\",\n    tags: {\n        Environment: \"test\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\ns3 = aws.ec2.VpcEndpoint(\"s3\",\n    vpc_id=main[\"id\"],\n    service_name=\"com.amazonaws.us-west-2.s3\",\n    tags={\n        \"Environment\": \"test\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var s3 = new Aws.Ec2.VpcEndpoint(\"s3\", new()\n    {\n        VpcId = main.Id,\n        ServiceName = \"com.amazonaws.us-west-2.s3\",\n        Tags = \n        {\n            { \"Environment\", \"test\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ec2.NewVpcEndpoint(ctx, \"s3\", \u0026ec2.VpcEndpointArgs{\n\t\t\tVpcId:       pulumi.Any(main.Id),\n\t\t\tServiceName: pulumi.String(\"com.amazonaws.us-west-2.s3\"),\n\t\t\tTags: pulumi.StringMap{\n\t\t\t\t\"Environment\": pulumi.String(\"test\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ec2.VpcEndpoint;\nimport com.pulumi.aws.ec2.VpcEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var s3 = new VpcEndpoint(\"s3\", VpcEndpointArgs.builder()        \n            .vpcId(main.id())\n            .serviceName(\"com.amazonaws.us-west-2.s3\")\n            .tags(Map.of(\"Environment\", \"test\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  s3:\n    type: aws:ec2:VpcEndpoint\n    properties:\n      vpcId: ${main.id}\n      serviceName: com.amazonaws.us-west-2.s3\n      tags:\n        Environment: test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Interface Endpoint Type\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst ec2 = new aws.ec2.VpcEndpoint(\"ec2\", {\n    vpcId: main.id,\n    serviceName: \"com.amazonaws.us-west-2.ec2\",\n    vpcEndpointType: \"Interface\",\n    securityGroupIds: [sg1.id],\n    privateDnsEnabled: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nec2 = aws.ec2.VpcEndpoint(\"ec2\",\n    vpc_id=main[\"id\"],\n    service_name=\"com.amazonaws.us-west-2.ec2\",\n    vpc_endpoint_type=\"Interface\",\n    security_group_ids=[sg1[\"id\"]],\n    private_dns_enabled=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ec2 = new Aws.Ec2.VpcEndpoint(\"ec2\", new()\n    {\n        VpcId = main.Id,\n        ServiceName = \"com.amazonaws.us-west-2.ec2\",\n        VpcEndpointType = \"Interface\",\n        SecurityGroupIds = new[]\n        {\n            sg1.Id,\n        },\n        PrivateDnsEnabled = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := ec2.NewVpcEndpoint(ctx, \"ec2\", \u0026ec2.VpcEndpointArgs{\n\t\t\tVpcId:           pulumi.Any(main.Id),\n\t\t\tServiceName:     pulumi.String(\"com.amazonaws.us-west-2.ec2\"),\n\t\t\tVpcEndpointType: pulumi.String(\"Interface\"),\n\t\t\tSecurityGroupIds: pulumi.StringArray{\n\t\t\t\tsg1.Id,\n\t\t\t},\n\t\t\tPrivateDnsEnabled: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ec2.VpcEndpoint;\nimport com.pulumi.aws.ec2.VpcEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ec2 = new VpcEndpoint(\"ec2\", VpcEndpointArgs.builder()        \n            .vpcId(main.id())\n            .serviceName(\"com.amazonaws.us-west-2.ec2\")\n            .vpcEndpointType(\"Interface\")\n            .securityGroupIds(sg1.id())\n            .privateDnsEnabled(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ec2:\n    type: aws:ec2:VpcEndpoint\n    properties:\n      vpcId: ${main.id}\n      serviceName: com.amazonaws.us-west-2.ec2\n      vpcEndpointType: Interface\n      securityGroupIds:\n        - ${sg1.id}\n      privateDnsEnabled: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Gateway Load Balancer Endpoint Type\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst current = aws.getCallerIdentity({});\nconst example = new aws.ec2.VpcEndpointService(\"example\", {\n    acceptanceRequired: false,\n    allowedPrincipals: [current.then(current =\u003e current.arn)],\n    gatewayLoadBalancerArns: [exampleAwsLb.arn],\n});\nconst exampleVpcEndpoint = new aws.ec2.VpcEndpoint(\"example\", {\n    serviceName: example.serviceName,\n    subnetIds: [exampleAwsSubnet.id],\n    vpcEndpointType: example.serviceType,\n    vpcId: exampleAwsVpc.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\ncurrent = aws.get_caller_identity()\nexample = aws.ec2.VpcEndpointService(\"example\",\n    acceptance_required=False,\n    allowed_principals=[current.arn],\n    gateway_load_balancer_arns=[example_aws_lb[\"arn\"]])\nexample_vpc_endpoint = aws.ec2.VpcEndpoint(\"example\",\n    service_name=example.service_name,\n    subnet_ids=[example_aws_subnet[\"id\"]],\n    vpc_endpoint_type=example.service_type,\n    vpc_id=example_aws_vpc[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var current = Aws.GetCallerIdentity.Invoke();\n\n    var example = new Aws.Ec2.VpcEndpointService(\"example\", new()\n    {\n        AcceptanceRequired = false,\n        AllowedPrincipals = new[]\n        {\n            current.Apply(getCallerIdentityResult =\u003e getCallerIdentityResult.Arn),\n        },\n        GatewayLoadBalancerArns = new[]\n        {\n            exampleAwsLb.Arn,\n        },\n    });\n\n    var exampleVpcEndpoint = new Aws.Ec2.VpcEndpoint(\"example\", new()\n    {\n        ServiceName = example.ServiceName,\n        SubnetIds = new[]\n        {\n            exampleAwsSubnet.Id,\n        },\n        VpcEndpointType = example.ServiceType,\n        VpcId = exampleAwsVpc.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcurrent, err := aws.GetCallerIdentity(ctx, nil, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texample, err := ec2.NewVpcEndpointService(ctx, \"example\", \u0026ec2.VpcEndpointServiceArgs{\n\t\t\tAcceptanceRequired: pulumi.Bool(false),\n\t\t\tAllowedPrincipals: pulumi.StringArray{\n\t\t\t\tpulumi.String(current.Arn),\n\t\t\t},\n\t\t\tGatewayLoadBalancerArns: pulumi.StringArray{\n\t\t\t\texampleAwsLb.Arn,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = ec2.NewVpcEndpoint(ctx, \"example\", \u0026ec2.VpcEndpointArgs{\n\t\t\tServiceName: example.ServiceName,\n\t\t\tSubnetIds: pulumi.StringArray{\n\t\t\t\texampleAwsSubnet.Id,\n\t\t\t},\n\t\t\tVpcEndpointType: example.ServiceType,\n\t\t\tVpcId:           pulumi.Any(exampleAwsVpc.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.AwsFunctions;\nimport com.pulumi.aws.inputs.GetCallerIdentityArgs;\nimport com.pulumi.aws.ec2.VpcEndpointService;\nimport com.pulumi.aws.ec2.VpcEndpointServiceArgs;\nimport com.pulumi.aws.ec2.VpcEndpoint;\nimport com.pulumi.aws.ec2.VpcEndpointArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var current = AwsFunctions.getCallerIdentity();\n\n        var example = new VpcEndpointService(\"example\", VpcEndpointServiceArgs.builder()        \n            .acceptanceRequired(false)\n            .allowedPrincipals(current.applyValue(getCallerIdentityResult -\u003e getCallerIdentityResult.arn()))\n            .gatewayLoadBalancerArns(exampleAwsLb.arn())\n            .build());\n\n        var exampleVpcEndpoint = new VpcEndpoint(\"exampleVpcEndpoint\", VpcEndpointArgs.builder()        \n            .serviceName(example.serviceName())\n            .subnetIds(exampleAwsSubnet.id())\n            .vpcEndpointType(example.serviceType())\n            .vpcId(exampleAwsVpc.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: aws:ec2:VpcEndpointService\n    properties:\n      acceptanceRequired: false\n      allowedPrincipals:\n        - ${current.arn}\n      gatewayLoadBalancerArns:\n        - ${exampleAwsLb.arn}\n  exampleVpcEndpoint:\n    type: aws:ec2:VpcEndpoint\n    name: example\n    properties:\n      serviceName: ${example.serviceName}\n      subnetIds:\n        - ${exampleAwsSubnet.id}\n      vpcEndpointType: ${example.serviceType}\n      vpcId: ${exampleAwsVpc.id}\nvariables:\n  current:\n    fn::invoke:\n      Function: aws:getCallerIdentity\n      Arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUsing `pulumi import`, import VPC Endpoints using the VPC endpoint `id`. For example:\n\n```sh\n$ pulumi import aws:ec2/vpcEndpoint:VpcEndpoint endpoint1 vpce-3ecf2a57\n```\n",
            "properties": {
                "autoAccept": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Accept the VPC endpoint (the VPC endpoint and service need to be in the same AWS account)."
                },
                "dnsOptions": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ec2/VpcEndpointDnsOptions:VpcEndpointDnsOptions",
                    "description": "The DNS options for the endpoint. See dns_options below.\n"
                },
                "ipAddressType": {
                    "type": "string",
                    "description": "The IP address type for the endpoint. Valid values are `ipv4`, `dualstack`, and `ipv6`.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "A policy to attach to the endpoint that controls access to the service. This is a JSON formatted string. Defaults to full access. All `Gateway` and some `Interface` endpoints support policies - see the [relevant AWS documentation](https://docs.aws.amazon.com/vpc/latest/userguide/vpc-endpoints-access.html) for more details.\n"
                },
                "privateDnsEnabled": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Whether or not to associate a private hosted zone with the specified VPC. Applicable for endpoints of type Interface. Defaults to `false`."
                },
                "routeTableIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "One or more route table IDs. Applicable for endpoints of type `Gateway`.\n"
                },
                "securityGroupIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of one or more security groups to associate with the network interface. Applicable for endpoints of type `Interface`.\nIf no security groups are specified, the VPC's [default security group](https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#DefaultSecurityGroup) is associated with the endpoint.\n"
                },
                "serviceName": {
                    "type": "string",
                    "plain": true,
                    "description": "The service name. For AWS services the service name is usually in the form `com.amazonaws.\u003cregion\u003e.\u003cservice\u003e` (the SageMaker Notebook service is an exception to this rule, the service name is in the form `aws.sagemaker.\u003cregion\u003e.notebook`)."
                },
                "subnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The ID of one or more subnets in which to create a network interface for the endpoint. Applicable for endpoints of type `GatewayLoadBalancer` and `Interface`. Interface type endpoints cannot function without being assigned to a subnet.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "vpcEndpointType": {
                    "type": "string",
                    "description": "The VPC endpoint type, `Gateway`, `GatewayLoadBalancer`, or `Interface`. Defaults to `Gateway`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "serviceName"
            ]
        },
        "awsx:ecr:BuilderVersion": {
            "description": "The version of the Docker builder",
            "type": "string",
            "enum": [
                {
                    "description": "The first generation builder for Docker Daemon.",
                    "value": "BuilderV1"
                },
                {
                    "description": "The builder based on moby/buildkit project",
                    "value": "BuilderBuildKit"
                }
            ]
        },
        "awsx:ecr:DockerBuild": {
            "description": "Arguments for building a docker image",
            "properties": {
                "args": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "An optional map of named build-time argument variables to set during the Docker build.  This flag allows you to pass built-time variables that can be accessed like environment variables inside the `RUN` instruction."
                },
                "builderVersion": {
                    "$ref": "#/types/awsx:ecr:BuilderVersion",
                    "plain": true,
                    "description": "The version of the Docker builder."
                },
                "cacheFrom": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Images to consider as cache sources"
                },
                "context": {
                    "type": "string",
                    "description": "Path to a directory to use for the Docker build context, usually the directory in which the Dockerfile resides (although dockerfile may be used to choose a custom location independent of this choice). If not specified, the context defaults to the current working directory; if a relative path is used, it is relative to the current working directory that Pulumi is evaluating."
                },
                "dockerfile": {
                    "type": "string",
                    "description": "dockerfile may be used to override the default Dockerfile name and/or location.  By default, it is assumed to be a file named Dockerfile in the root of the build context."
                },
                "imageName": {
                    "type": "string",
                    "description": "Custom name for the underlying Docker image resource. If omitted, the image tag assigned by the provider will be used"
                },
                "imageTag": {
                    "type": "string",
                    "description": "Custom image tag for the resulting docker image. If omitted a random string will be used"
                },
                "platform": {
                    "type": "string",
                    "description": "The architecture of the platform you want to build this image for, e.g. `linux/arm64`."
                },
                "target": {
                    "type": "string",
                    "description": "The target of the dockerfile to build"
                }
            },
            "type": "object"
        },
        "awsx:ecr:lifecyclePolicy": {
            "description": "Simplified lifecycle policy model consisting of one or more rules that determine which images in a repository should be expired. See https://docs.aws.amazon.com/AmazonECR/latest/userguide/lifecycle_policy_examples.html for more details.",
            "properties": {
                "rules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecr:lifecyclePolicyRule"
                    },
                    "description": "Specifies the rules to determine how images should be retired from this repository. Rules are ordered from lowest priority to highest.  If there is a rule with a `selection` value of `any`, then it will have the highest priority."
                },
                "skip": {
                    "type": "boolean",
                    "plain": true,
                    "description": "Skips creation of the policy if set to `true`."
                }
            },
            "type": "object"
        },
        "awsx:ecr:lifecyclePolicyRule": {
            "description": "A lifecycle policy rule that determine which images in a repository should be expired.",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Describes the purpose of a rule within a lifecycle policy."
                },
                "maximumAgeLimit": {
                    "type": "number",
                    "description": "The maximum age limit (in days) for your images. Either [maximumNumberOfImages] or [maximumAgeLimit] must be provided."
                },
                "maximumNumberOfImages": {
                    "type": "number",
                    "description": "The maximum number of images that you want to retain in your repository. Either [maximumNumberOfImages] or [maximumAgeLimit] must be provided."
                },
                "tagPrefixList": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of image tag prefixes on which to take action with your lifecycle policy. Only used if you specified \"tagStatus\": \"tagged\". For example, if your images are tagged as prod, prod1, prod2, and so on, you would use the tag prefix prod to specify all of them. If you specify multiple tags, only the images with all specified tags are selected."
                },
                "tagStatus": {
                    "$ref": "#/types/awsx:ecr:lifecycleTagStatus",
                    "description": "Determines whether the lifecycle policy rule that you are adding specifies a tag for an image. Acceptable options are tagged, untagged, or any. If you specify any, then all images have the rule evaluated against them. If you specify tagged, then you must also specify a tagPrefixList value. If you specify untagged, then you must omit tagPrefixList."
                }
            },
            "type": "object",
            "required": [
                "tagStatus"
            ]
        },
        "awsx:ecr:lifecycleTagStatus": {
            "type": "string",
            "enum": [
                {
                    "name": "any",
                    "description": "Evaluate rule against all images",
                    "value": "any"
                },
                {
                    "name": "untagged",
                    "description": "Only evaluate rule against untagged images",
                    "value": "untagged"
                },
                {
                    "name": "tagged",
                    "description": "Only evaluated rule against images with specified prefixes",
                    "value": "tagged"
                }
            ]
        },
        "awsx:ecs:EC2ServiceTaskDefinition": {
            "description": "Create a TaskDefinition resource with the given unique name, arguments, and options.\nCreates required log-group and task \u0026 execution roles.\nPresents required Service load balancers if target group included in port mappings.",
            "properties": {
                "container": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                    "plain": true,
                    "description": "Single container to make a TaskDefinition from.  Useful for simple cases where there aren't\nmultiple containers, especially when creating a TaskDefinition to call [run] on.\n\nEither [container] or [containers] must be provided."
                },
                "containers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                        "plain": true
                    },
                    "plain": true,
                    "description": "All the containers to make a TaskDefinition from.  Useful when creating a Service that will\ncontain many containers within.\n\nEither [container] or [containers] must be provided."
                },
                "cpu": {
                    "type": "string",
                    "description": "The number of cpu units used by the task. If not provided, a default will be computed based on the cumulative needs specified by [containerDefinitions]"
                },
                "ephemeralStorage": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionEphemeralStorage:TaskDefinitionEphemeralStorage",
                    "description": "The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on AWS Fargate. See Ephemeral Storage.\n",
                    "willReplaceOnChanges": true
                },
                "executionRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "The execution role that the Amazon ECS container agent and the Docker daemon can assume.\nWill be created automatically if not defined."
                },
                "family": {
                    "type": "string",
                    "description": "An optional unique name for your task definition. If not specified, then a default will be created."
                },
                "inferenceAccelerators": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionInferenceAccelerator:TaskDefinitionInferenceAccelerator"
                    },
                    "description": "Configuration block(s) with Inference Accelerators settings. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "ipcMode": {
                    "type": "string",
                    "description": "IPC resource namespace to be used for the containers in the task The valid values are `host`, `task`, and `none`.\n",
                    "willReplaceOnChanges": true
                },
                "logGroup": {
                    "$ref": "#/types/awsx:awsx:DefaultLogGroup",
                    "plain": true,
                    "description": "A set of volume blocks that containers in your task may use."
                },
                "memory": {
                    "type": "string",
                    "description": "The amount (in MiB) of memory used by the task.  If not provided, a default will be computed\nbased on the cumulative needs specified by [containerDefinitions]"
                },
                "networkMode": {
                    "type": "string",
                    "description": "Docker networking mode to use for the containers in the task. Valid values are `none`, `bridge`, `awsvpc`, and `host`.\n",
                    "willReplaceOnChanges": true
                },
                "pidMode": {
                    "type": "string",
                    "description": "Process namespace to use for the containers in the task. The valid values are `host` and `task`.\n",
                    "willReplaceOnChanges": true
                },
                "placementConstraints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionPlacementConstraint:TaskDefinitionPlacementConstraint"
                    },
                    "description": "Configuration block for rules that are taken into consideration during task placement. Maximum number of `placement_constraints` is `10`. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "proxyConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionProxyConfiguration:TaskDefinitionProxyConfiguration",
                    "description": "Configuration block for the App Mesh proxy. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "runtimePlatform": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionRuntimePlatform:TaskDefinitionRuntimePlatform",
                    "description": "Configuration block for runtime_platform that containers in your task may use.\n",
                    "willReplaceOnChanges": true
                },
                "skipDestroy": {
                    "type": "boolean",
                    "description": "Whether to retain the old revision when the resource is destroyed or replacement is necessary. Default is `false`.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "taskRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "IAM role that allows your Amazon ECS container task to make calls to other AWS services.\nWill be created automatically if not defined."
                },
                "trackLatest": {
                    "type": "boolean",
                    "description": "Whether should track latest task definition or the one created with the resource. Default is `false`.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionVolume:TaskDefinitionVolume"
                    },
                    "description": "Configuration block for volumes that containers in your task may use. Detailed below.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "awsx:ecs:FargateServiceTaskDefinition": {
            "description": "Create a TaskDefinition resource with the given unique name, arguments, and options.\nCreates required log-group and task \u0026 execution roles.\nPresents required Service load balancers if target group included in port mappings.",
            "properties": {
                "container": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                    "plain": true,
                    "description": "Single container to make a TaskDefinition from.  Useful for simple cases where there aren't\nmultiple containers, especially when creating a TaskDefinition to call [run] on.\n\nEither [container] or [containers] must be provided."
                },
                "containers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                        "plain": true
                    },
                    "plain": true,
                    "description": "All the containers to make a TaskDefinition from.  Useful when creating a Service that will\ncontain many containers within.\n\nEither [container] or [containers] must be provided."
                },
                "cpu": {
                    "type": "string",
                    "description": "The number of cpu units used by the task. If not provided, a default will be computed based on the cumulative needs specified by [containerDefinitions]"
                },
                "ephemeralStorage": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionEphemeralStorage:TaskDefinitionEphemeralStorage",
                    "description": "The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on AWS Fargate. See Ephemeral Storage.\n",
                    "willReplaceOnChanges": true
                },
                "executionRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "The execution role that the Amazon ECS container agent and the Docker daemon can assume.\nWill be created automatically if not defined."
                },
                "family": {
                    "type": "string",
                    "description": "An optional unique name for your task definition. If not specified, then a default will be created."
                },
                "inferenceAccelerators": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionInferenceAccelerator:TaskDefinitionInferenceAccelerator"
                    },
                    "description": "Configuration block(s) with Inference Accelerators settings. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "ipcMode": {
                    "type": "string",
                    "description": "IPC resource namespace to be used for the containers in the task The valid values are `host`, `task`, and `none`.\n",
                    "willReplaceOnChanges": true
                },
                "logGroup": {
                    "$ref": "#/types/awsx:awsx:DefaultLogGroup",
                    "plain": true,
                    "description": "A set of volume blocks that containers in your task may use."
                },
                "memory": {
                    "type": "string",
                    "description": "The amount (in MiB) of memory used by the task.  If not provided, a default will be computed\nbased on the cumulative needs specified by [containerDefinitions]"
                },
                "pidMode": {
                    "type": "string",
                    "description": "Process namespace to use for the containers in the task. The valid values are `host` and `task`.\n",
                    "willReplaceOnChanges": true
                },
                "placementConstraints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionPlacementConstraint:TaskDefinitionPlacementConstraint"
                    },
                    "description": "Configuration block for rules that are taken into consideration during task placement. Maximum number of `placement_constraints` is `10`. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "proxyConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionProxyConfiguration:TaskDefinitionProxyConfiguration",
                    "description": "Configuration block for the App Mesh proxy. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "runtimePlatform": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionRuntimePlatform:TaskDefinitionRuntimePlatform",
                    "description": "Configuration block for runtime_platform that containers in your task may use.\n",
                    "willReplaceOnChanges": true
                },
                "skipDestroy": {
                    "type": "boolean",
                    "description": "Whether to retain the old revision when the resource is destroyed or replacement is necessary. Default is `false`.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "taskRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "IAM role that allows your Amazon ECS container task to make calls to other AWS services.\nWill be created automatically if not defined."
                },
                "trackLatest": {
                    "type": "boolean",
                    "description": "Whether should track latest task definition or the one created with the resource. Default is `false`.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionVolume:TaskDefinitionVolume"
                    },
                    "description": "Configuration block for volumes that containers in your task may use. Detailed below.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionContainerDefinition": {
            "description": "List of container definitions that are passed to the Docker daemon on a container instance",
            "properties": {
                "command": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "cpu": {
                    "type": "integer"
                },
                "dependsOn": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDependency"
                    }
                },
                "disableNetworking": {
                    "type": "boolean"
                },
                "dnsSearchDomains": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "dockerLabels": {
                    "$ref": "pulumi.json#/Any"
                },
                "dockerSecurityOptions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "entryPoint": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "environment": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionKeyValuePair"
                    },
                    "description": "The environment variables to pass to a container"
                },
                "environmentFiles": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionEnvironmentFile"
                    },
                    "description": "The list of one or more files that contain the environment variables to pass to a container"
                },
                "essential": {
                    "type": "boolean"
                },
                "extraHosts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionHostEntry"
                    }
                },
                "firelensConfiguration": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionFirelensConfiguration"
                },
                "healthCheck": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionHealthCheck"
                },
                "hostname": {
                    "type": "string"
                },
                "image": {
                    "type": "string",
                    "description": "The image used to start a container. This string is passed directly to the Docker daemon."
                },
                "interactive": {
                    "type": "boolean"
                },
                "links": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "linuxParameters": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionLinuxParameters"
                },
                "logConfiguration": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionLogConfiguration"
                },
                "memory": {
                    "type": "integer",
                    "description": "The amount (in MiB) of memory to present to the container. If your container attempts to exceed the memory specified here, the container is killed."
                },
                "memoryReservation": {
                    "type": "integer"
                },
                "mountPoints": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionMountPoint"
                    }
                },
                "name": {
                    "type": "string",
                    "description": "The name of a container. Up to 255 letters (uppercase and lowercase), numbers, hyphens, and underscores are allowed"
                },
                "portMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionPortMapping"
                    },
                    "description": "Port mappings allow containers to access ports on the host container instance to send or receive traffic."
                },
                "privileged": {
                    "type": "boolean"
                },
                "pseudoTerminal": {
                    "type": "boolean"
                },
                "readonlyRootFilesystem": {
                    "type": "boolean"
                },
                "repositoryCredentials": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionRepositoryCredentials"
                },
                "resourceRequirements": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionResourceRequirement"
                    }
                },
                "secrets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionSecret"
                    }
                },
                "startTimeout": {
                    "type": "integer"
                },
                "stopTimeout": {
                    "type": "integer"
                },
                "systemControls": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionSystemControl"
                    }
                },
                "ulimits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionUlimit"
                    }
                },
                "user": {
                    "type": "string"
                },
                "volumesFrom": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionVolumeFrom"
                    }
                },
                "workingDirectory": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "image",
                "name"
            ]
        },
        "awsx:ecs:TaskDefinitionContainerDependency": {
            "properties": {
                "condition": {
                    "type": "string"
                },
                "containerName": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionDevice": {
            "properties": {
                "containerPath": {
                    "type": "string"
                },
                "hostPath": {
                    "type": "string"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionEnvironmentFile": {
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionFirelensConfiguration": {
            "properties": {
                "options": {
                    "$ref": "pulumi.json#/Any"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionHealthCheck": {
            "description": "The health check command and associated configuration parameters for the container.",
            "properties": {
                "command": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A string array representing the command that the container runs to determine if it is healthy."
                },
                "interval": {
                    "type": "integer",
                    "description": "The time period in seconds between each health check execution. You may specify between 5 and 300 seconds. The default value is 30 seconds."
                },
                "retries": {
                    "type": "integer",
                    "description": "The number of times to retry a failed health check before the container is considered unhealthy. You may specify between 1 and 10 retries. The default value is three retries."
                },
                "startPeriod": {
                    "type": "integer",
                    "description": "The optional grace period within which to provide containers time to bootstrap before failed health checks count towards the maximum number of retries. You may specify between 0 and 300 seconds. The startPeriod is disabled by default."
                },
                "timeout": {
                    "type": "integer",
                    "description": "The time period in seconds to wait for a health check to succeed before it is considered a failure. You may specify between 2 and 60 seconds. The default value is 5 seconds."
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionHostEntry": {
            "properties": {
                "hostname": {
                    "type": "string"
                },
                "ipAddress": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionKernelCapabilities": {
            "properties": {
                "add": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "drop": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionKeyValuePair": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionLinuxParameters": {
            "properties": {
                "capabilities": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionKernelCapabilities"
                },
                "devices": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionDevice"
                    }
                },
                "initProcessEnabled": {
                    "type": "boolean"
                },
                "maxSwap": {
                    "type": "integer"
                },
                "sharedMemorySize": {
                    "type": "integer"
                },
                "swappiness": {
                    "type": "integer"
                },
                "tmpfs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionTmpfs"
                    }
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionLogConfiguration": {
            "properties": {
                "logDriver": {
                    "type": "string"
                },
                "options": {
                    "$ref": "pulumi.json#/Any"
                },
                "secretOptions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionSecret"
                    }
                }
            },
            "type": "object",
            "required": [
                "logDriver"
            ]
        },
        "awsx:ecs:TaskDefinitionMountPoint": {
            "properties": {
                "containerPath": {
                    "type": "string"
                },
                "readOnly": {
                    "type": "boolean"
                },
                "sourceVolume": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionPortMapping": {
            "properties": {
                "appProtocol": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionPortMappingAppProtocol"
                },
                "containerPort": {
                    "type": "integer"
                },
                "containerPortRange": {
                    "type": "string"
                },
                "hostPort": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                },
                "targetGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2FtargetGroup:TargetGroup"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionPortMappingAppProtocol": {
            "type": "string",
            "enum": [
                {
                    "name": "Http",
                    "value": "http"
                },
                {
                    "name": "Http2",
                    "value": "http2"
                },
                {
                    "name": "Grpc",
                    "value": "grpc"
                }
            ]
        },
        "awsx:ecs:TaskDefinitionRepositoryCredentials": {
            "properties": {
                "credentialsParameter": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionResourceRequirement": {
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "type",
                "value"
            ]
        },
        "awsx:ecs:TaskDefinitionSecret": {
            "properties": {
                "name": {
                    "type": "string"
                },
                "valueFrom": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "name",
                "valueFrom"
            ]
        },
        "awsx:ecs:TaskDefinitionSystemControl": {
            "properties": {
                "namespace": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:ecs:TaskDefinitionTmpfs": {
            "properties": {
                "containerPath": {
                    "type": "string"
                },
                "mountOptions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "size": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "size"
            ]
        },
        "awsx:ecs:TaskDefinitionUlimit": {
            "properties": {
                "hardLimit": {
                    "type": "integer"
                },
                "name": {
                    "type": "string"
                },
                "softLimit": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "hardLimit",
                "name",
                "softLimit"
            ]
        },
        "awsx:ecs:TaskDefinitionVolumeFrom": {
            "properties": {
                "readOnly": {
                    "type": "boolean"
                },
                "sourceContainer": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "awsx:lb:Listener": {
            "description": "Provides a Load Balancer Listener resource.\n\n\u003e **Note:** `aws.alb.Listener` is known as `aws.lb.Listener`. The functionality is identical.\n\n## Example Usage\n\n### Forward Action\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst frontEnd = new aws.lb.LoadBalancer(\"front_end\", {});\nconst frontEndTargetGroup = new aws.lb.TargetGroup(\"front_end\", {});\nconst frontEndListener = new aws.lb.Listener(\"front_end\", {\n    loadBalancerArn: frontEnd.arn,\n    port: 443,\n    protocol: \"HTTPS\",\n    sslPolicy: \"ELBSecurityPolicy-2016-08\",\n    certificateArn: \"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\",\n    defaultActions: [{\n        type: \"forward\",\n        targetGroupArn: frontEndTargetGroup.arn,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nfront_end = aws.lb.LoadBalancer(\"front_end\")\nfront_end_target_group = aws.lb.TargetGroup(\"front_end\")\nfront_end_listener = aws.lb.Listener(\"front_end\",\n    load_balancer_arn=front_end.arn,\n    port=443,\n    protocol=\"HTTPS\",\n    ssl_policy=\"ELBSecurityPolicy-2016-08\",\n    certificate_arn=\"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\",\n    default_actions=[aws.lb.ListenerDefaultActionArgs(\n        type=\"forward\",\n        target_group_arn=front_end_target_group.arn,\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var frontEnd = new Aws.LB.LoadBalancer(\"front_end\");\n\n    var frontEndTargetGroup = new Aws.LB.TargetGroup(\"front_end\");\n\n    var frontEndListener = new Aws.LB.Listener(\"front_end\", new()\n    {\n        LoadBalancerArn = frontEnd.Arn,\n        Port = 443,\n        Protocol = \"HTTPS\",\n        SslPolicy = \"ELBSecurityPolicy-2016-08\",\n        CertificateArn = \"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\",\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"forward\",\n                TargetGroupArn = frontEndTargetGroup.Arn,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfrontEnd, err := lb.NewLoadBalancer(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfrontEndTargetGroup, err := lb.NewTargetGroup(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"front_end\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: frontEnd.Arn,\n\t\t\tPort:            pulumi.Int(443),\n\t\t\tProtocol:        pulumi.String(\"HTTPS\"),\n\t\t\tSslPolicy:       pulumi.String(\"ELBSecurityPolicy-2016-08\"),\n\t\t\tCertificateArn:  pulumi.String(\"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\"),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType:           pulumi.String(\"forward\"),\n\t\t\t\t\tTargetGroupArn: frontEndTargetGroup.Arn,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var frontEnd = new LoadBalancer(\"frontEnd\");\n\n        var frontEndTargetGroup = new TargetGroup(\"frontEndTargetGroup\");\n\n        var frontEndListener = new Listener(\"frontEndListener\", ListenerArgs.builder()        \n            .loadBalancerArn(frontEnd.arn())\n            .port(\"443\")\n            .protocol(\"HTTPS\")\n            .sslPolicy(\"ELBSecurityPolicy-2016-08\")\n            .certificateArn(\"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\")\n            .defaultActions(ListenerDefaultActionArgs.builder()\n                .type(\"forward\")\n                .targetGroupArn(frontEndTargetGroup.arn())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  frontEnd:\n    type: aws:lb:LoadBalancer\n    name: front_end\n  frontEndTargetGroup:\n    type: aws:lb:TargetGroup\n    name: front_end\n  frontEndListener:\n    type: aws:lb:Listener\n    name: front_end\n    properties:\n      loadBalancerArn: ${frontEnd.arn}\n      port: '443'\n      protocol: HTTPS\n      sslPolicy: ELBSecurityPolicy-2016-08\n      certificateArn: arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\n      defaultActions:\n        - type: forward\n          targetGroupArn: ${frontEndTargetGroup.arn}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nTo a NLB:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst frontEnd = new aws.lb.Listener(\"front_end\", {\n    loadBalancerArn: frontEndAwsLb.arn,\n    port: 443,\n    protocol: \"TLS\",\n    certificateArn: \"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\",\n    alpnPolicy: \"HTTP2Preferred\",\n    defaultActions: [{\n        type: \"forward\",\n        targetGroupArn: frontEndAwsLbTargetGroup.arn,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nfront_end = aws.lb.Listener(\"front_end\",\n    load_balancer_arn=front_end_aws_lb[\"arn\"],\n    port=443,\n    protocol=\"TLS\",\n    certificate_arn=\"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\",\n    alpn_policy=\"HTTP2Preferred\",\n    default_actions=[aws.lb.ListenerDefaultActionArgs(\n        type=\"forward\",\n        target_group_arn=front_end_aws_lb_target_group[\"arn\"],\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var frontEnd = new Aws.LB.Listener(\"front_end\", new()\n    {\n        LoadBalancerArn = frontEndAwsLb.Arn,\n        Port = 443,\n        Protocol = \"TLS\",\n        CertificateArn = \"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\",\n        AlpnPolicy = \"HTTP2Preferred\",\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"forward\",\n                TargetGroupArn = frontEndAwsLbTargetGroup.Arn,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := lb.NewListener(ctx, \"front_end\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: pulumi.Any(frontEndAwsLb.Arn),\n\t\t\tPort:            pulumi.Int(443),\n\t\t\tProtocol:        pulumi.String(\"TLS\"),\n\t\t\tCertificateArn:  pulumi.String(\"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\"),\n\t\t\tAlpnPolicy:      pulumi.String(\"HTTP2Preferred\"),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType:           pulumi.String(\"forward\"),\n\t\t\t\t\tTargetGroupArn: pulumi.Any(frontEndAwsLbTargetGroup.Arn),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var frontEnd = new Listener(\"frontEnd\", ListenerArgs.builder()        \n            .loadBalancerArn(frontEndAwsLb.arn())\n            .port(\"443\")\n            .protocol(\"TLS\")\n            .certificateArn(\"arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\")\n            .alpnPolicy(\"HTTP2Preferred\")\n            .defaultActions(ListenerDefaultActionArgs.builder()\n                .type(\"forward\")\n                .targetGroupArn(frontEndAwsLbTargetGroup.arn())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  frontEnd:\n    type: aws:lb:Listener\n    name: front_end\n    properties:\n      loadBalancerArn: ${frontEndAwsLb.arn}\n      port: '443'\n      protocol: TLS\n      certificateArn: arn:aws:iam::187416307283:server-certificate/test_cert_rab3wuqwgja25ct3n4jdj2tzu4\n      alpnPolicy: HTTP2Preferred\n      defaultActions:\n        - type: forward\n          targetGroupArn: ${frontEndAwsLbTargetGroup.arn}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Redirect Action\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst frontEnd = new aws.lb.LoadBalancer(\"front_end\", {});\nconst frontEndListener = new aws.lb.Listener(\"front_end\", {\n    loadBalancerArn: frontEnd.arn,\n    port: 80,\n    protocol: \"HTTP\",\n    defaultActions: [{\n        type: \"redirect\",\n        redirect: {\n            port: \"443\",\n            protocol: \"HTTPS\",\n            statusCode: \"HTTP_301\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nfront_end = aws.lb.LoadBalancer(\"front_end\")\nfront_end_listener = aws.lb.Listener(\"front_end\",\n    load_balancer_arn=front_end.arn,\n    port=80,\n    protocol=\"HTTP\",\n    default_actions=[aws.lb.ListenerDefaultActionArgs(\n        type=\"redirect\",\n        redirect=aws.lb.ListenerDefaultActionRedirectArgs(\n            port=\"443\",\n            protocol=\"HTTPS\",\n            status_code=\"HTTP_301\",\n        ),\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var frontEnd = new Aws.LB.LoadBalancer(\"front_end\");\n\n    var frontEndListener = new Aws.LB.Listener(\"front_end\", new()\n    {\n        LoadBalancerArn = frontEnd.Arn,\n        Port = 80,\n        Protocol = \"HTTP\",\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"redirect\",\n                Redirect = new Aws.LB.Inputs.ListenerDefaultActionRedirectArgs\n                {\n                    Port = \"443\",\n                    Protocol = \"HTTPS\",\n                    StatusCode = \"HTTP_301\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfrontEnd, err := lb.NewLoadBalancer(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"front_end\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: frontEnd.Arn,\n\t\t\tPort:            pulumi.Int(80),\n\t\t\tProtocol:        pulumi.String(\"HTTP\"),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType: pulumi.String(\"redirect\"),\n\t\t\t\t\tRedirect: \u0026lb.ListenerDefaultActionRedirectArgs{\n\t\t\t\t\t\tPort:       pulumi.String(\"443\"),\n\t\t\t\t\t\tProtocol:   pulumi.String(\"HTTPS\"),\n\t\t\t\t\t\tStatusCode: pulumi.String(\"HTTP_301\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionRedirectArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var frontEnd = new LoadBalancer(\"frontEnd\");\n\n        var frontEndListener = new Listener(\"frontEndListener\", ListenerArgs.builder()        \n            .loadBalancerArn(frontEnd.arn())\n            .port(\"80\")\n            .protocol(\"HTTP\")\n            .defaultActions(ListenerDefaultActionArgs.builder()\n                .type(\"redirect\")\n                .redirect(ListenerDefaultActionRedirectArgs.builder()\n                    .port(\"443\")\n                    .protocol(\"HTTPS\")\n                    .statusCode(\"HTTP_301\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  frontEnd:\n    type: aws:lb:LoadBalancer\n    name: front_end\n  frontEndListener:\n    type: aws:lb:Listener\n    name: front_end\n    properties:\n      loadBalancerArn: ${frontEnd.arn}\n      port: '80'\n      protocol: HTTP\n      defaultActions:\n        - type: redirect\n          redirect:\n            port: '443'\n            protocol: HTTPS\n            statusCode: HTTP_301\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Fixed-response Action\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst frontEnd = new aws.lb.LoadBalancer(\"front_end\", {});\nconst frontEndListener = new aws.lb.Listener(\"front_end\", {\n    loadBalancerArn: frontEnd.arn,\n    port: 80,\n    protocol: \"HTTP\",\n    defaultActions: [{\n        type: \"fixed-response\",\n        fixedResponse: {\n            contentType: \"text/plain\",\n            messageBody: \"Fixed response content\",\n            statusCode: \"200\",\n        },\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nfront_end = aws.lb.LoadBalancer(\"front_end\")\nfront_end_listener = aws.lb.Listener(\"front_end\",\n    load_balancer_arn=front_end.arn,\n    port=80,\n    protocol=\"HTTP\",\n    default_actions=[aws.lb.ListenerDefaultActionArgs(\n        type=\"fixed-response\",\n        fixed_response=aws.lb.ListenerDefaultActionFixedResponseArgs(\n            content_type=\"text/plain\",\n            message_body=\"Fixed response content\",\n            status_code=\"200\",\n        ),\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var frontEnd = new Aws.LB.LoadBalancer(\"front_end\");\n\n    var frontEndListener = new Aws.LB.Listener(\"front_end\", new()\n    {\n        LoadBalancerArn = frontEnd.Arn,\n        Port = 80,\n        Protocol = \"HTTP\",\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"fixed-response\",\n                FixedResponse = new Aws.LB.Inputs.ListenerDefaultActionFixedResponseArgs\n                {\n                    ContentType = \"text/plain\",\n                    MessageBody = \"Fixed response content\",\n                    StatusCode = \"200\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfrontEnd, err := lb.NewLoadBalancer(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"front_end\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: frontEnd.Arn,\n\t\t\tPort:            pulumi.Int(80),\n\t\t\tProtocol:        pulumi.String(\"HTTP\"),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType: pulumi.String(\"fixed-response\"),\n\t\t\t\t\tFixedResponse: \u0026lb.ListenerDefaultActionFixedResponseArgs{\n\t\t\t\t\t\tContentType: pulumi.String(\"text/plain\"),\n\t\t\t\t\t\tMessageBody: pulumi.String(\"Fixed response content\"),\n\t\t\t\t\t\tStatusCode:  pulumi.String(\"200\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionFixedResponseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var frontEnd = new LoadBalancer(\"frontEnd\");\n\n        var frontEndListener = new Listener(\"frontEndListener\", ListenerArgs.builder()        \n            .loadBalancerArn(frontEnd.arn())\n            .port(\"80\")\n            .protocol(\"HTTP\")\n            .defaultActions(ListenerDefaultActionArgs.builder()\n                .type(\"fixed-response\")\n                .fixedResponse(ListenerDefaultActionFixedResponseArgs.builder()\n                    .contentType(\"text/plain\")\n                    .messageBody(\"Fixed response content\")\n                    .statusCode(\"200\")\n                    .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  frontEnd:\n    type: aws:lb:LoadBalancer\n    name: front_end\n  frontEndListener:\n    type: aws:lb:Listener\n    name: front_end\n    properties:\n      loadBalancerArn: ${frontEnd.arn}\n      port: '80'\n      protocol: HTTP\n      defaultActions:\n        - type: fixed-response\n          fixedResponse:\n            contentType: text/plain\n            messageBody: Fixed response content\n            statusCode: '200'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Authenticate-cognito Action\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst frontEnd = new aws.lb.LoadBalancer(\"front_end\", {});\nconst frontEndTargetGroup = new aws.lb.TargetGroup(\"front_end\", {});\nconst pool = new aws.cognito.UserPool(\"pool\", {});\nconst client = new aws.cognito.UserPoolClient(\"client\", {});\nconst domain = new aws.cognito.UserPoolDomain(\"domain\", {});\nconst frontEndListener = new aws.lb.Listener(\"front_end\", {\n    loadBalancerArn: frontEnd.arn,\n    port: 80,\n    protocol: \"HTTP\",\n    defaultActions: [\n        {\n            type: \"authenticate-cognito\",\n            authenticateCognito: {\n                userPoolArn: pool.arn,\n                userPoolClientId: client.id,\n                userPoolDomain: domain.domain,\n            },\n        },\n        {\n            type: \"forward\",\n            targetGroupArn: frontEndTargetGroup.arn,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nfront_end = aws.lb.LoadBalancer(\"front_end\")\nfront_end_target_group = aws.lb.TargetGroup(\"front_end\")\npool = aws.cognito.UserPool(\"pool\")\nclient = aws.cognito.UserPoolClient(\"client\")\ndomain = aws.cognito.UserPoolDomain(\"domain\")\nfront_end_listener = aws.lb.Listener(\"front_end\",\n    load_balancer_arn=front_end.arn,\n    port=80,\n    protocol=\"HTTP\",\n    default_actions=[\n        aws.lb.ListenerDefaultActionArgs(\n            type=\"authenticate-cognito\",\n            authenticate_cognito=aws.lb.ListenerDefaultActionAuthenticateCognitoArgs(\n                user_pool_arn=pool.arn,\n                user_pool_client_id=client.id,\n                user_pool_domain=domain.domain,\n            ),\n        ),\n        aws.lb.ListenerDefaultActionArgs(\n            type=\"forward\",\n            target_group_arn=front_end_target_group.arn,\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var frontEnd = new Aws.LB.LoadBalancer(\"front_end\");\n\n    var frontEndTargetGroup = new Aws.LB.TargetGroup(\"front_end\");\n\n    var pool = new Aws.Cognito.UserPool(\"pool\");\n\n    var client = new Aws.Cognito.UserPoolClient(\"client\");\n\n    var domain = new Aws.Cognito.UserPoolDomain(\"domain\");\n\n    var frontEndListener = new Aws.LB.Listener(\"front_end\", new()\n    {\n        LoadBalancerArn = frontEnd.Arn,\n        Port = 80,\n        Protocol = \"HTTP\",\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"authenticate-cognito\",\n                AuthenticateCognito = new Aws.LB.Inputs.ListenerDefaultActionAuthenticateCognitoArgs\n                {\n                    UserPoolArn = pool.Arn,\n                    UserPoolClientId = client.Id,\n                    UserPoolDomain = domain.Domain,\n                },\n            },\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"forward\",\n                TargetGroupArn = frontEndTargetGroup.Arn,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/cognito\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfrontEnd, err := lb.NewLoadBalancer(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfrontEndTargetGroup, err := lb.NewTargetGroup(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpool, err := cognito.NewUserPool(ctx, \"pool\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tclient, err := cognito.NewUserPoolClient(ctx, \"client\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdomain, err := cognito.NewUserPoolDomain(ctx, \"domain\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"front_end\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: frontEnd.Arn,\n\t\t\tPort:            pulumi.Int(80),\n\t\t\tProtocol:        pulumi.String(\"HTTP\"),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType: pulumi.String(\"authenticate-cognito\"),\n\t\t\t\t\tAuthenticateCognito: \u0026lb.ListenerDefaultActionAuthenticateCognitoArgs{\n\t\t\t\t\t\tUserPoolArn:      pool.Arn,\n\t\t\t\t\t\tUserPoolClientId: client.ID(),\n\t\t\t\t\t\tUserPoolDomain:   domain.Domain,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType:           pulumi.String(\"forward\"),\n\t\t\t\t\tTargetGroupArn: frontEndTargetGroup.Arn,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.cognito.UserPool;\nimport com.pulumi.aws.cognito.UserPoolClient;\nimport com.pulumi.aws.cognito.UserPoolDomain;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionAuthenticateCognitoArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var frontEnd = new LoadBalancer(\"frontEnd\");\n\n        var frontEndTargetGroup = new TargetGroup(\"frontEndTargetGroup\");\n\n        var pool = new UserPool(\"pool\");\n\n        var client = new UserPoolClient(\"client\");\n\n        var domain = new UserPoolDomain(\"domain\");\n\n        var frontEndListener = new Listener(\"frontEndListener\", ListenerArgs.builder()        \n            .loadBalancerArn(frontEnd.arn())\n            .port(\"80\")\n            .protocol(\"HTTP\")\n            .defaultActions(            \n                ListenerDefaultActionArgs.builder()\n                    .type(\"authenticate-cognito\")\n                    .authenticateCognito(ListenerDefaultActionAuthenticateCognitoArgs.builder()\n                        .userPoolArn(pool.arn())\n                        .userPoolClientId(client.id())\n                        .userPoolDomain(domain.domain())\n                        .build())\n                    .build(),\n                ListenerDefaultActionArgs.builder()\n                    .type(\"forward\")\n                    .targetGroupArn(frontEndTargetGroup.arn())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  frontEnd:\n    type: aws:lb:LoadBalancer\n    name: front_end\n  frontEndTargetGroup:\n    type: aws:lb:TargetGroup\n    name: front_end\n  pool:\n    type: aws:cognito:UserPool\n  client:\n    type: aws:cognito:UserPoolClient\n  domain:\n    type: aws:cognito:UserPoolDomain\n  frontEndListener:\n    type: aws:lb:Listener\n    name: front_end\n    properties:\n      loadBalancerArn: ${frontEnd.arn}\n      port: '80'\n      protocol: HTTP\n      defaultActions:\n        - type: authenticate-cognito\n          authenticateCognito:\n            userPoolArn: ${pool.arn}\n            userPoolClientId: ${client.id}\n            userPoolDomain: ${domain.domain}\n        - type: forward\n          targetGroupArn: ${frontEndTargetGroup.arn}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Authenticate-OIDC Action\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst frontEnd = new aws.lb.LoadBalancer(\"front_end\", {});\nconst frontEndTargetGroup = new aws.lb.TargetGroup(\"front_end\", {});\nconst frontEndListener = new aws.lb.Listener(\"front_end\", {\n    loadBalancerArn: frontEnd.arn,\n    port: 80,\n    protocol: \"HTTP\",\n    defaultActions: [\n        {\n            type: \"authenticate-oidc\",\n            authenticateOidc: {\n                authorizationEndpoint: \"https://example.com/authorization_endpoint\",\n                clientId: \"client_id\",\n                clientSecret: \"client_secret\",\n                issuer: \"https://example.com\",\n                tokenEndpoint: \"https://example.com/token_endpoint\",\n                userInfoEndpoint: \"https://example.com/user_info_endpoint\",\n            },\n        },\n        {\n            type: \"forward\",\n            targetGroupArn: frontEndTargetGroup.arn,\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nfront_end = aws.lb.LoadBalancer(\"front_end\")\nfront_end_target_group = aws.lb.TargetGroup(\"front_end\")\nfront_end_listener = aws.lb.Listener(\"front_end\",\n    load_balancer_arn=front_end.arn,\n    port=80,\n    protocol=\"HTTP\",\n    default_actions=[\n        aws.lb.ListenerDefaultActionArgs(\n            type=\"authenticate-oidc\",\n            authenticate_oidc=aws.lb.ListenerDefaultActionAuthenticateOidcArgs(\n                authorization_endpoint=\"https://example.com/authorization_endpoint\",\n                client_id=\"client_id\",\n                client_secret=\"client_secret\",\n                issuer=\"https://example.com\",\n                token_endpoint=\"https://example.com/token_endpoint\",\n                user_info_endpoint=\"https://example.com/user_info_endpoint\",\n            ),\n        ),\n        aws.lb.ListenerDefaultActionArgs(\n            type=\"forward\",\n            target_group_arn=front_end_target_group.arn,\n        ),\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var frontEnd = new Aws.LB.LoadBalancer(\"front_end\");\n\n    var frontEndTargetGroup = new Aws.LB.TargetGroup(\"front_end\");\n\n    var frontEndListener = new Aws.LB.Listener(\"front_end\", new()\n    {\n        LoadBalancerArn = frontEnd.Arn,\n        Port = 80,\n        Protocol = \"HTTP\",\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"authenticate-oidc\",\n                AuthenticateOidc = new Aws.LB.Inputs.ListenerDefaultActionAuthenticateOidcArgs\n                {\n                    AuthorizationEndpoint = \"https://example.com/authorization_endpoint\",\n                    ClientId = \"client_id\",\n                    ClientSecret = \"client_secret\",\n                    Issuer = \"https://example.com\",\n                    TokenEndpoint = \"https://example.com/token_endpoint\",\n                    UserInfoEndpoint = \"https://example.com/user_info_endpoint\",\n                },\n            },\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                Type = \"forward\",\n                TargetGroupArn = frontEndTargetGroup.Arn,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tfrontEnd, err := lb.NewLoadBalancer(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfrontEndTargetGroup, err := lb.NewTargetGroup(ctx, \"front_end\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"front_end\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: frontEnd.Arn,\n\t\t\tPort:            pulumi.Int(80),\n\t\t\tProtocol:        pulumi.String(\"HTTP\"),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType: pulumi.String(\"authenticate-oidc\"),\n\t\t\t\t\tAuthenticateOidc: \u0026lb.ListenerDefaultActionAuthenticateOidcArgs{\n\t\t\t\t\t\tAuthorizationEndpoint: pulumi.String(\"https://example.com/authorization_endpoint\"),\n\t\t\t\t\t\tClientId:              pulumi.String(\"client_id\"),\n\t\t\t\t\t\tClientSecret:          pulumi.String(\"client_secret\"),\n\t\t\t\t\t\tIssuer:                pulumi.String(\"https://example.com\"),\n\t\t\t\t\t\tTokenEndpoint:         pulumi.String(\"https://example.com/token_endpoint\"),\n\t\t\t\t\t\tUserInfoEndpoint:      pulumi.String(\"https://example.com/user_info_endpoint\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tType:           pulumi.String(\"forward\"),\n\t\t\t\t\tTargetGroupArn: frontEndTargetGroup.Arn,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionAuthenticateOidcArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var frontEnd = new LoadBalancer(\"frontEnd\");\n\n        var frontEndTargetGroup = new TargetGroup(\"frontEndTargetGroup\");\n\n        var frontEndListener = new Listener(\"frontEndListener\", ListenerArgs.builder()        \n            .loadBalancerArn(frontEnd.arn())\n            .port(\"80\")\n            .protocol(\"HTTP\")\n            .defaultActions(            \n                ListenerDefaultActionArgs.builder()\n                    .type(\"authenticate-oidc\")\n                    .authenticateOidc(ListenerDefaultActionAuthenticateOidcArgs.builder()\n                        .authorizationEndpoint(\"https://example.com/authorization_endpoint\")\n                        .clientId(\"client_id\")\n                        .clientSecret(\"client_secret\")\n                        .issuer(\"https://example.com\")\n                        .tokenEndpoint(\"https://example.com/token_endpoint\")\n                        .userInfoEndpoint(\"https://example.com/user_info_endpoint\")\n                        .build())\n                    .build(),\n                ListenerDefaultActionArgs.builder()\n                    .type(\"forward\")\n                    .targetGroupArn(frontEndTargetGroup.arn())\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  frontEnd:\n    type: aws:lb:LoadBalancer\n    name: front_end\n  frontEndTargetGroup:\n    type: aws:lb:TargetGroup\n    name: front_end\n  frontEndListener:\n    type: aws:lb:Listener\n    name: front_end\n    properties:\n      loadBalancerArn: ${frontEnd.arn}\n      port: '80'\n      protocol: HTTP\n      defaultActions:\n        - type: authenticate-oidc\n          authenticateOidc:\n            authorizationEndpoint: https://example.com/authorization_endpoint\n            clientId: client_id\n            clientSecret: client_secret\n            issuer: https://example.com\n            tokenEndpoint: https://example.com/token_endpoint\n            userInfoEndpoint: https://example.com/user_info_endpoint\n        - type: forward\n          targetGroupArn: ${frontEndTargetGroup.arn}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Gateway Load Balancer Listener\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst example = new aws.lb.LoadBalancer(\"example\", {\n    loadBalancerType: \"gateway\",\n    name: \"example\",\n    subnetMappings: [{\n        subnetId: exampleAwsSubnet.id,\n    }],\n});\nconst exampleTargetGroup = new aws.lb.TargetGroup(\"example\", {\n    name: \"example\",\n    port: 6081,\n    protocol: \"GENEVE\",\n    vpcId: exampleAwsVpc.id,\n    healthCheck: {\n        port: \"80\",\n        protocol: \"HTTP\",\n    },\n});\nconst exampleListener = new aws.lb.Listener(\"example\", {\n    loadBalancerArn: example.id,\n    defaultActions: [{\n        targetGroupArn: exampleTargetGroup.id,\n        type: \"forward\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nexample = aws.lb.LoadBalancer(\"example\",\n    load_balancer_type=\"gateway\",\n    name=\"example\",\n    subnet_mappings=[aws.lb.LoadBalancerSubnetMappingArgs(\n        subnet_id=example_aws_subnet[\"id\"],\n    )])\nexample_target_group = aws.lb.TargetGroup(\"example\",\n    name=\"example\",\n    port=6081,\n    protocol=\"GENEVE\",\n    vpc_id=example_aws_vpc[\"id\"],\n    health_check=aws.lb.TargetGroupHealthCheckArgs(\n        port=\"80\",\n        protocol=\"HTTP\",\n    ))\nexample_listener = aws.lb.Listener(\"example\",\n    load_balancer_arn=example.id,\n    default_actions=[aws.lb.ListenerDefaultActionArgs(\n        target_group_arn=example_target_group.id,\n        type=\"forward\",\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Aws.LB.LoadBalancer(\"example\", new()\n    {\n        LoadBalancerType = \"gateway\",\n        Name = \"example\",\n        SubnetMappings = new[]\n        {\n            new Aws.LB.Inputs.LoadBalancerSubnetMappingArgs\n            {\n                SubnetId = exampleAwsSubnet.Id,\n            },\n        },\n    });\n\n    var exampleTargetGroup = new Aws.LB.TargetGroup(\"example\", new()\n    {\n        Name = \"example\",\n        Port = 6081,\n        Protocol = \"GENEVE\",\n        VpcId = exampleAwsVpc.Id,\n        HealthCheck = new Aws.LB.Inputs.TargetGroupHealthCheckArgs\n        {\n            Port = \"80\",\n            Protocol = \"HTTP\",\n        },\n    });\n\n    var exampleListener = new Aws.LB.Listener(\"example\", new()\n    {\n        LoadBalancerArn = example.Id,\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                TargetGroupArn = exampleTargetGroup.Id,\n                Type = \"forward\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := lb.NewLoadBalancer(ctx, \"example\", \u0026lb.LoadBalancerArgs{\n\t\t\tLoadBalancerType: pulumi.String(\"gateway\"),\n\t\t\tName:             pulumi.String(\"example\"),\n\t\t\tSubnetMappings: lb.LoadBalancerSubnetMappingArray{\n\t\t\t\t\u0026lb.LoadBalancerSubnetMappingArgs{\n\t\t\t\t\tSubnetId: pulumi.Any(exampleAwsSubnet.Id),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleTargetGroup, err := lb.NewTargetGroup(ctx, \"example\", \u0026lb.TargetGroupArgs{\n\t\t\tName:     pulumi.String(\"example\"),\n\t\t\tPort:     pulumi.Int(6081),\n\t\t\tProtocol: pulumi.String(\"GENEVE\"),\n\t\t\tVpcId:    pulumi.Any(exampleAwsVpc.Id),\n\t\t\tHealthCheck: \u0026lb.TargetGroupHealthCheckArgs{\n\t\t\t\tPort:     pulumi.String(\"80\"),\n\t\t\t\tProtocol: pulumi.String(\"HTTP\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"example\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: example.ID(),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tTargetGroupArn: exampleTargetGroup.ID(),\n\t\t\t\t\tType:           pulumi.String(\"forward\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.LoadBalancerArgs;\nimport com.pulumi.aws.lb.inputs.LoadBalancerSubnetMappingArgs;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.TargetGroupArgs;\nimport com.pulumi.aws.lb.inputs.TargetGroupHealthCheckArgs;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LoadBalancer(\"example\", LoadBalancerArgs.builder()        \n            .loadBalancerType(\"gateway\")\n            .name(\"example\")\n            .subnetMappings(LoadBalancerSubnetMappingArgs.builder()\n                .subnetId(exampleAwsSubnet.id())\n                .build())\n            .build());\n\n        var exampleTargetGroup = new TargetGroup(\"exampleTargetGroup\", TargetGroupArgs.builder()        \n            .name(\"example\")\n            .port(6081)\n            .protocol(\"GENEVE\")\n            .vpcId(exampleAwsVpc.id())\n            .healthCheck(TargetGroupHealthCheckArgs.builder()\n                .port(80)\n                .protocol(\"HTTP\")\n                .build())\n            .build());\n\n        var exampleListener = new Listener(\"exampleListener\", ListenerArgs.builder()        \n            .loadBalancerArn(example.id())\n            .defaultActions(ListenerDefaultActionArgs.builder()\n                .targetGroupArn(exampleTargetGroup.id())\n                .type(\"forward\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: aws:lb:LoadBalancer\n    properties:\n      loadBalancerType: gateway\n      name: example\n      subnetMappings:\n        - subnetId: ${exampleAwsSubnet.id}\n  exampleTargetGroup:\n    type: aws:lb:TargetGroup\n    name: example\n    properties:\n      name: example\n      port: 6081\n      protocol: GENEVE\n      vpcId: ${exampleAwsVpc.id}\n      healthCheck:\n        port: 80\n        protocol: HTTP\n  exampleListener:\n    type: aws:lb:Listener\n    name: example\n    properties:\n      loadBalancerArn: ${example.id}\n      defaultActions:\n        - targetGroupArn: ${exampleTargetGroup.id}\n          type: forward\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Mutual TLS Authentication\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst example = new aws.lb.LoadBalancer(\"example\", {loadBalancerType: \"application\"});\nconst exampleTargetGroup = new aws.lb.TargetGroup(\"example\", {});\nconst exampleListener = new aws.lb.Listener(\"example\", {\n    loadBalancerArn: example.id,\n    defaultActions: [{\n        targetGroupArn: exampleTargetGroup.id,\n        type: \"forward\",\n    }],\n    mutualAuthentication: {\n        mode: \"verify\",\n        trustStoreArn: \"...\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nexample = aws.lb.LoadBalancer(\"example\", load_balancer_type=\"application\")\nexample_target_group = aws.lb.TargetGroup(\"example\")\nexample_listener = aws.lb.Listener(\"example\",\n    load_balancer_arn=example.id,\n    default_actions=[aws.lb.ListenerDefaultActionArgs(\n        target_group_arn=example_target_group.id,\n        type=\"forward\",\n    )],\n    mutual_authentication=aws.lb.ListenerMutualAuthenticationArgs(\n        mode=\"verify\",\n        trust_store_arn=\"...\",\n    ))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var example = new Aws.LB.LoadBalancer(\"example\", new()\n    {\n        LoadBalancerType = \"application\",\n    });\n\n    var exampleTargetGroup = new Aws.LB.TargetGroup(\"example\");\n\n    var exampleListener = new Aws.LB.Listener(\"example\", new()\n    {\n        LoadBalancerArn = example.Id,\n        DefaultActions = new[]\n        {\n            new Aws.LB.Inputs.ListenerDefaultActionArgs\n            {\n                TargetGroupArn = exampleTargetGroup.Id,\n                Type = \"forward\",\n            },\n        },\n        MutualAuthentication = new Aws.LB.Inputs.ListenerMutualAuthenticationArgs\n        {\n            Mode = \"verify\",\n            TrustStoreArn = \"...\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\texample, err := lb.NewLoadBalancer(ctx, \"example\", \u0026lb.LoadBalancerArgs{\n\t\t\tLoadBalancerType: pulumi.String(\"application\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\texampleTargetGroup, err := lb.NewTargetGroup(ctx, \"example\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewListener(ctx, \"example\", \u0026lb.ListenerArgs{\n\t\t\tLoadBalancerArn: example.ID(),\n\t\t\tDefaultActions: lb.ListenerDefaultActionArray{\n\t\t\t\t\u0026lb.ListenerDefaultActionArgs{\n\t\t\t\t\tTargetGroupArn: exampleTargetGroup.ID(),\n\t\t\t\t\tType:           pulumi.String(\"forward\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tMutualAuthentication: \u0026lb.ListenerMutualAuthenticationArgs{\n\t\t\t\tMode:          pulumi.String(\"verify\"),\n\t\t\t\tTrustStoreArn: pulumi.String(\"...\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.LoadBalancer;\nimport com.pulumi.aws.lb.LoadBalancerArgs;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.Listener;\nimport com.pulumi.aws.lb.ListenerArgs;\nimport com.pulumi.aws.lb.inputs.ListenerDefaultActionArgs;\nimport com.pulumi.aws.lb.inputs.ListenerMutualAuthenticationArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var example = new LoadBalancer(\"example\", LoadBalancerArgs.builder()        \n            .loadBalancerType(\"application\")\n            .build());\n\n        var exampleTargetGroup = new TargetGroup(\"exampleTargetGroup\");\n\n        var exampleListener = new Listener(\"exampleListener\", ListenerArgs.builder()        \n            .loadBalancerArn(example.id())\n            .defaultActions(ListenerDefaultActionArgs.builder()\n                .targetGroupArn(exampleTargetGroup.id())\n                .type(\"forward\")\n                .build())\n            .mutualAuthentication(ListenerMutualAuthenticationArgs.builder()\n                .mode(\"verify\")\n                .trustStoreArn(\"...\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  example:\n    type: aws:lb:LoadBalancer\n    properties:\n      loadBalancerType: application\n  exampleTargetGroup:\n    type: aws:lb:TargetGroup\n    name: example\n  exampleListener:\n    type: aws:lb:Listener\n    name: example\n    properties:\n      loadBalancerArn: ${example.id}\n      defaultActions:\n        - targetGroupArn: ${exampleTargetGroup.id}\n          type: forward\n      mutualAuthentication:\n        mode: verify\n        trustStoreArn: '...'\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUsing `pulumi import`, import listeners using their ARN. For example:\n\n```sh\n$ pulumi import aws:lb/listener:Listener front_end arn:aws:elasticloadbalancing:us-west-2:187416307283:listener/app/front-end-alb/8e4497da625e2d8a/9ab28ade35828f96\n```\n",
            "properties": {
                "alpnPolicy": {
                    "type": "string",
                    "description": "Name of the Application-Layer Protocol Negotiation (ALPN) policy. Can be set if `protocol` is `TLS`. Valid values are `HTTP1Only`, `HTTP2Only`, `HTTP2Optional`, `HTTP2Preferred`, and `None`.\n"
                },
                "certificateArn": {
                    "type": "string",
                    "description": "ARN of the default SSL server certificate. Exactly one certificate is required if the protocol is HTTPS. For adding additional SSL certificates, see the `aws.lb.ListenerCertificate` resource.\n"
                },
                "defaultActions": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/ListenerDefaultAction:ListenerDefaultAction"
                    },
                    "description": "Configuration block for default actions. Detailed below.\n"
                },
                "mutualAuthentication": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/ListenerMutualAuthentication:ListenerMutualAuthentication",
                    "description": "The mutual authentication configuration information. Detailed below.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port on which the load balancer is listening. Not valid for Gateway Load Balancers.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol for connections from clients to the load balancer. For Application Load Balancers, valid values are `HTTP` and `HTTPS`, with a default of `HTTP`. For Network Load Balancers, valid values are `TCP`, `TLS`, `UDP`, and `TCP_UDP`. Not valid to use `UDP` or `TCP_UDP` if dual-stack mode is enabled. Not valid for Gateway Load Balancers.\n"
                },
                "sslPolicy": {
                    "type": "string",
                    "description": "Name of the SSL Policy for the listener. Required if `protocol` is `HTTPS` or `TLS`.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource. .If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n\n\u003e **NOTE::** Please note that listeners that are attached to Application Load Balancers must use either `HTTP` or `HTTPS` protocols while listeners that are attached to Network Load Balancers must use the `TCP` protocol.\n"
                }
            },
            "type": "object"
        },
        "awsx:lb:TargetGroup": {
            "description": "Provides a Target Group resource for use with Load Balancer resources.\n\n\u003e **Note:** `aws.alb.TargetGroup` is known as `aws.lb.TargetGroup`. The functionality is identical.\n\n## Example Usage\n\n### Instance Target Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst main = new aws.ec2.Vpc(\"main\", {cidrBlock: \"10.0.0.0/16\"});\nconst test = new aws.lb.TargetGroup(\"test\", {\n    name: \"tf-example-lb-tg\",\n    port: 80,\n    protocol: \"HTTP\",\n    vpcId: main.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nmain = aws.ec2.Vpc(\"main\", cidr_block=\"10.0.0.0/16\")\ntest = aws.lb.TargetGroup(\"test\",\n    name=\"tf-example-lb-tg\",\n    port=80,\n    protocol=\"HTTP\",\n    vpc_id=main.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new Aws.Ec2.Vpc(\"main\", new()\n    {\n        CidrBlock = \"10.0.0.0/16\",\n    });\n\n    var test = new Aws.LB.TargetGroup(\"test\", new()\n    {\n        Name = \"tf-example-lb-tg\",\n        Port = 80,\n        Protocol = \"HTTP\",\n        VpcId = main.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := ec2.NewVpc(ctx, \"main\", \u0026ec2.VpcArgs{\n\t\t\tCidrBlock: pulumi.String(\"10.0.0.0/16\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewTargetGroup(ctx, \"test\", \u0026lb.TargetGroupArgs{\n\t\t\tName:     pulumi.String(\"tf-example-lb-tg\"),\n\t\t\tPort:     pulumi.Int(80),\n\t\t\tProtocol: pulumi.String(\"HTTP\"),\n\t\t\tVpcId:    main.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ec2.Vpc;\nimport com.pulumi.aws.ec2.VpcArgs;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.TargetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new Vpc(\"main\", VpcArgs.builder()        \n            .cidrBlock(\"10.0.0.0/16\")\n            .build());\n\n        var test = new TargetGroup(\"test\", TargetGroupArgs.builder()        \n            .name(\"tf-example-lb-tg\")\n            .port(80)\n            .protocol(\"HTTP\")\n            .vpcId(main.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: aws:lb:TargetGroup\n    properties:\n      name: tf-example-lb-tg\n      port: 80\n      protocol: HTTP\n      vpcId: ${main.id}\n  main:\n    type: aws:ec2:Vpc\n    properties:\n      cidrBlock: 10.0.0.0/16\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### IP Target Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst main = new aws.ec2.Vpc(\"main\", {cidrBlock: \"10.0.0.0/16\"});\nconst ip_example = new aws.lb.TargetGroup(\"ip-example\", {\n    name: \"tf-example-lb-tg\",\n    port: 80,\n    protocol: \"HTTP\",\n    targetType: \"ip\",\n    vpcId: main.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nmain = aws.ec2.Vpc(\"main\", cidr_block=\"10.0.0.0/16\")\nip_example = aws.lb.TargetGroup(\"ip-example\",\n    name=\"tf-example-lb-tg\",\n    port=80,\n    protocol=\"HTTP\",\n    target_type=\"ip\",\n    vpc_id=main.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var main = new Aws.Ec2.Vpc(\"main\", new()\n    {\n        CidrBlock = \"10.0.0.0/16\",\n    });\n\n    var ip_example = new Aws.LB.TargetGroup(\"ip-example\", new()\n    {\n        Name = \"tf-example-lb-tg\",\n        Port = 80,\n        Protocol = \"HTTP\",\n        TargetType = \"ip\",\n        VpcId = main.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ec2\"\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tmain, err := ec2.NewVpc(ctx, \"main\", \u0026ec2.VpcArgs{\n\t\t\tCidrBlock: pulumi.String(\"10.0.0.0/16\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = lb.NewTargetGroup(ctx, \"ip-example\", \u0026lb.TargetGroupArgs{\n\t\t\tName:       pulumi.String(\"tf-example-lb-tg\"),\n\t\t\tPort:       pulumi.Int(80),\n\t\t\tProtocol:   pulumi.String(\"HTTP\"),\n\t\t\tTargetType: pulumi.String(\"ip\"),\n\t\t\tVpcId:      main.ID(),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.ec2.Vpc;\nimport com.pulumi.aws.ec2.VpcArgs;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.TargetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var main = new Vpc(\"main\", VpcArgs.builder()        \n            .cidrBlock(\"10.0.0.0/16\")\n            .build());\n\n        var ip_example = new TargetGroup(\"ip-example\", TargetGroupArgs.builder()        \n            .name(\"tf-example-lb-tg\")\n            .port(80)\n            .protocol(\"HTTP\")\n            .targetType(\"ip\")\n            .vpcId(main.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ip-example:\n    type: aws:lb:TargetGroup\n    properties:\n      name: tf-example-lb-tg\n      port: 80\n      protocol: HTTP\n      targetType: ip\n      vpcId: ${main.id}\n  main:\n    type: aws:ec2:Vpc\n    properties:\n      cidrBlock: 10.0.0.0/16\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Lambda Target Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst lambda_example = new aws.lb.TargetGroup(\"lambda-example\", {\n    name: \"tf-example-lb-tg\",\n    targetType: \"lambda\",\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nlambda_example = aws.lb.TargetGroup(\"lambda-example\",\n    name=\"tf-example-lb-tg\",\n    target_type=\"lambda\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var lambda_example = new Aws.LB.TargetGroup(\"lambda-example\", new()\n    {\n        Name = \"tf-example-lb-tg\",\n        TargetType = \"lambda\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := lb.NewTargetGroup(ctx, \"lambda-example\", \u0026lb.TargetGroupArgs{\n\t\t\tName:       pulumi.String(\"tf-example-lb-tg\"),\n\t\t\tTargetType: pulumi.String(\"lambda\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.TargetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var lambda_example = new TargetGroup(\"lambda-example\", TargetGroupArgs.builder()        \n            .name(\"tf-example-lb-tg\")\n            .targetType(\"lambda\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  lambda-example:\n    type: aws:lb:TargetGroup\n    properties:\n      name: tf-example-lb-tg\n      targetType: lambda\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### ALB Target Group\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst alb_example = new aws.lb.TargetGroup(\"alb-example\", {\n    name: \"tf-example-lb-alb-tg\",\n    targetType: \"alb\",\n    port: 80,\n    protocol: \"TCP\",\n    vpcId: main.id,\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\nalb_example = aws.lb.TargetGroup(\"alb-example\",\n    name=\"tf-example-lb-alb-tg\",\n    target_type=\"alb\",\n    port=80,\n    protocol=\"TCP\",\n    vpc_id=main[\"id\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var alb_example = new Aws.LB.TargetGroup(\"alb-example\", new()\n    {\n        Name = \"tf-example-lb-alb-tg\",\n        TargetType = \"alb\",\n        Port = 80,\n        Protocol = \"TCP\",\n        VpcId = main.Id,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := lb.NewTargetGroup(ctx, \"alb-example\", \u0026lb.TargetGroupArgs{\n\t\t\tName:       pulumi.String(\"tf-example-lb-alb-tg\"),\n\t\t\tTargetType: pulumi.String(\"alb\"),\n\t\t\tPort:       pulumi.Int(80),\n\t\t\tProtocol:   pulumi.String(\"TCP\"),\n\t\t\tVpcId:      pulumi.Any(main.Id),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.TargetGroupArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var alb_example = new TargetGroup(\"alb-example\", TargetGroupArgs.builder()        \n            .name(\"tf-example-lb-alb-tg\")\n            .targetType(\"alb\")\n            .port(80)\n            .protocol(\"TCP\")\n            .vpcId(main.id())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  alb-example:\n    type: aws:lb:TargetGroup\n    properties:\n      name: tf-example-lb-alb-tg\n      targetType: alb\n      port: 80\n      protocol: TCP\n      vpcId: ${main.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### Target group with unhealthy connection termination disabled\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\n\nconst tcp_example = new aws.lb.TargetGroup(\"tcp-example\", {\n    name: \"tf-example-lb-nlb-tg\",\n    port: 25,\n    protocol: \"TCP\",\n    vpcId: main.id,\n    targetHealthStates: [{\n        enableUnhealthyConnectionTermination: false,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\n\ntcp_example = aws.lb.TargetGroup(\"tcp-example\",\n    name=\"tf-example-lb-nlb-tg\",\n    port=25,\n    protocol=\"TCP\",\n    vpc_id=main[\"id\"],\n    target_health_states=[aws.lb.TargetGroupTargetHealthStateArgs(\n        enable_unhealthy_connection_termination=False,\n    )])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tcp_example = new Aws.LB.TargetGroup(\"tcp-example\", new()\n    {\n        Name = \"tf-example-lb-nlb-tg\",\n        Port = 25,\n        Protocol = \"TCP\",\n        VpcId = main.Id,\n        TargetHealthStates = new[]\n        {\n            new Aws.LB.Inputs.TargetGroupTargetHealthStateArgs\n            {\n                EnableUnhealthyConnectionTermination = false,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/lb\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := lb.NewTargetGroup(ctx, \"tcp-example\", \u0026lb.TargetGroupArgs{\n\t\t\tName:     pulumi.String(\"tf-example-lb-nlb-tg\"),\n\t\t\tPort:     pulumi.Int(25),\n\t\t\tProtocol: pulumi.String(\"TCP\"),\n\t\t\tVpcId:    pulumi.Any(main.Id),\n\t\t\tTargetHealthStates: lb.TargetGroupTargetHealthStateArray{\n\t\t\t\t\u0026lb.TargetGroupTargetHealthStateArgs{\n\t\t\t\t\tEnableUnhealthyConnectionTermination: pulumi.Bool(false),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.aws.lb.TargetGroup;\nimport com.pulumi.aws.lb.TargetGroupArgs;\nimport com.pulumi.aws.lb.inputs.TargetGroupTargetHealthStateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var tcp_example = new TargetGroup(\"tcp-example\", TargetGroupArgs.builder()        \n            .name(\"tf-example-lb-nlb-tg\")\n            .port(25)\n            .protocol(\"TCP\")\n            .vpcId(main.id())\n            .targetHealthStates(TargetGroupTargetHealthStateArgs.builder()\n                .enableUnhealthyConnectionTermination(false)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  tcp-example:\n    type: aws:lb:TargetGroup\n    properties:\n      name: tf-example-lb-nlb-tg\n      port: 25\n      protocol: TCP\n      vpcId: ${main.id}\n      targetHealthStates:\n        - enableUnhealthyConnectionTermination: false\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nUsing `pulumi import`, import Target Groups using their ARN. For example:\n\n```sh\n$ pulumi import aws:lb/targetGroup:TargetGroup app_front_end arn:aws:elasticloadbalancing:us-west-2:187416307283:targetgroup/app-front-end/20cfe21448b66314\n```\n",
            "properties": {
                "connectionTermination": {
                    "type": "boolean",
                    "description": "Whether to terminate connections at the end of the deregistration timeout on Network Load Balancers. See [doc](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#deregistration-delay) for more information. Default is `false`.\n"
                },
                "deregistrationDelay": {
                    "type": "integer",
                    "description": "Amount time for Elastic Load Balancing to wait before changing the state of a deregistering target from draining to unused. The range is 0-3600 seconds. The default value is 300 seconds.\n"
                },
                "healthCheck": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/TargetGroupHealthCheck:TargetGroupHealthCheck",
                    "description": "Health Check configuration block. Detailed below.\n"
                },
                "ipAddressType": {
                    "type": "string",
                    "description": "The type of IP addresses used by the target group, only supported when target type is set to `ip`. Possible values are `ipv4` or `ipv6`.\n",
                    "willReplaceOnChanges": true
                },
                "lambdaMultiValueHeadersEnabled": {
                    "type": "boolean",
                    "description": "Whether the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings. Only applies when `target_type` is `lambda`. Default is `false`.\n"
                },
                "loadBalancingAlgorithmType": {
                    "type": "string",
                    "description": "Determines how the load balancer selects targets when routing requests. Only applicable for Application Load Balancer Target Groups. The value is `round_robin`, `least_outstanding_requests`, or `weighted_random`. The default is `round_robin`.\n"
                },
                "loadBalancingAnomalyMitigation": {
                    "type": "string",
                    "description": "Determines whether to enable target anomaly mitigation.  Target anomaly mitigation is only supported by the `weighted_random` load balancing algorithm type.  See [doc](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#automatic-target-weights) for more information.  The value is `\"on\"` or `\"off\"`. The default is `\"off\"`.\n"
                },
                "loadBalancingCrossZoneEnabled": {
                    "type": "string",
                    "description": "Indicates whether cross zone load balancing is enabled. The value is `\"true\"`, `\"false\"` or `\"use_load_balancer_configuration\"`. The default is `\"use_load_balancer_configuration\"`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the target group. If omitted, this provider will assign a random, unique name. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen.\n",
                    "willReplaceOnChanges": true
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique name beginning with the specified prefix. Conflicts with `name`. Cannot be longer than 6 characters.\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "integer",
                    "description": "Port on which targets receive traffic, unless overridden when registering a specific target. Required when `target_type` is `instance`, `ip` or `alb`. Does not apply when `target_type` is `lambda`.\n",
                    "willReplaceOnChanges": true
                },
                "preserveClientIp": {
                    "type": "string",
                    "description": "Whether client IP preservation is enabled. See [doc](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#client-ip-preservation) for more information.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Protocol to use for routing traffic to the targets.\nShould be one of `GENEVE`, `HTTP`, `HTTPS`, `TCP`, `TCP_UDP`, `TLS`, or `UDP`.\nRequired when `target_type` is `instance`, `ip`, or `alb`.\nDoes not apply when `target_type` is `lambda`.\n",
                    "willReplaceOnChanges": true
                },
                "protocolVersion": {
                    "type": "string",
                    "description": "Only applicable when `protocol` is `HTTP` or `HTTPS`. The protocol version. Specify `GRPC` to send requests to targets using gRPC. Specify `HTTP2` to send requests to targets using HTTP/2. The default is `HTTP1`, which sends requests to targets using HTTP/1.1\n",
                    "willReplaceOnChanges": true
                },
                "proxyProtocolV2": {
                    "type": "boolean",
                    "description": "Whether to enable support for proxy protocol v2 on Network Load Balancers. See [doc](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html#proxy-protocol) for more information. Default is `false`.\n"
                },
                "slowStart": {
                    "type": "integer",
                    "description": "Amount time for targets to warm up before the load balancer sends them a full share of requests. The range is 30-900 seconds or 0 to disable. The default value is 0 seconds.\n"
                },
                "stickiness": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/TargetGroupStickiness:TargetGroupStickiness",
                    "description": "Stickiness configuration block. Detailed below.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "targetFailovers": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/TargetGroupTargetFailover:TargetGroupTargetFailover"
                    },
                    "description": "Target failover block. Only applicable for Gateway Load Balancer target groups. See target_failover for more information.\n"
                },
                "targetHealthStates": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/TargetGroupTargetHealthState:TargetGroupTargetHealthState"
                    },
                    "description": "Target health state block. Only applicable for Network Load Balancer target groups when `protocol` is `TCP` or `TLS`. See target_health_state for more information.\n"
                },
                "targetType": {
                    "type": "string",
                    "description": "Type of target that you must specify when registering targets with this target group.\nSee [doc](https://docs.aws.amazon.com/elasticloadbalancing/latest/APIReference/API_CreateTargetGroup.html) for supported values.\nThe default is `instance`.\n\nNote that you can't specify targets for a target group using both instance IDs and IP addresses.\n\nIf the target type is `ip`, specify IP addresses from the subnets of the virtual private cloud (VPC) for the target group, the RFC 1918 range (10.0.0.0/8, 172.16.0.0/12, and 192.168.0.0/16), and the RFC 6598 range (100.64.0.0/10). You can't specify publicly routable IP addresses.\n\nNetwork Load Balancers do not support the `lambda` target type.\n\nApplication Load Balancers do not support the `alb` target type.\n",
                    "willReplaceOnChanges": true
                },
                "vpcId": {
                    "type": "string",
                    "description": "Identifier of the VPC in which to create the target group. Required when `target_type` is `instance`, `ip` or `alb`. Does not apply when `target_type` is `lambda`.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        }
    },
    "provider": {},
    "resources": {
        "awsx:cloudtrail:Trail": {
            "properties": {
                "bucket": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:s3%2Fbucket:Bucket",
                    "description": "The managed S3 Bucket where the Trail will place its logs."
                },
                "logGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:cloudwatch%2FlogGroup:LogGroup",
                    "description": "The managed Cloudwatch Log Group."
                },
                "trail": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:cloudtrail%2Ftrail:Trail",
                    "description": "The CloudTrail Trail.",
                    "language": {
                        "csharp": {
                            "name": "AwsTrail"
                        }
                    }
                }
            },
            "required": [
                "trail"
            ],
            "inputProperties": {
                "advancedEventSelectors": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:cloudtrail/TrailAdvancedEventSelector:TrailAdvancedEventSelector"
                    },
                    "description": "Specifies an advanced event selector for enabling data event logging. Fields documented below. Conflicts with `event_selector`.\n"
                },
                "cloudWatchLogsGroup": {
                    "$ref": "#/types/awsx:awsx:OptionalLogGroup",
                    "plain": true,
                    "description": "Log group to which CloudTrail logs will be delivered."
                },
                "enableLogFileValidation": {
                    "type": "boolean",
                    "description": "Whether log file integrity validation is enabled. Defaults to `false`.\n"
                },
                "enableLogging": {
                    "type": "boolean",
                    "description": "Enables logging for the trail. Defaults to `true`. Setting this to `false` will pause logging.\n"
                },
                "eventSelectors": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:cloudtrail/TrailEventSelector:TrailEventSelector"
                    },
                    "description": "Specifies an event selector for enabling data event logging. Fields documented below. Please note the [CloudTrail limits](https://docs.aws.amazon.com/awscloudtrail/latest/userguide/WhatIsCloudTrail-Limits.html) when configuring these. Conflicts with `advanced_event_selector`.\n"
                },
                "includeGlobalServiceEvents": {
                    "type": "boolean",
                    "description": "Whether the trail is publishing events from global services such as IAM to the log files. Defaults to `true`.\n"
                },
                "insightSelectors": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:cloudtrail/TrailInsightSelector:TrailInsightSelector"
                    },
                    "description": "Configuration block for identifying unusual operational activity. See details below.\n"
                },
                "isMultiRegionTrail": {
                    "type": "boolean",
                    "description": "Whether the trail is created in the current region or in all regions. Defaults to `false`.\n"
                },
                "isOrganizationTrail": {
                    "type": "boolean",
                    "description": "Whether the trail is an AWS Organizations trail. Organization trails log events for the master account and all member accounts. Can only be created in the organization master account. Defaults to `false`.\n"
                },
                "kmsKeyId": {
                    "type": "string",
                    "description": "KMS key ARN to use to encrypt the logs delivered by CloudTrail.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the trail.\n",
                    "willReplaceOnChanges": true
                },
                "s3Bucket": {
                    "$ref": "#/types/awsx:awsx:RequiredBucket",
                    "plain": true,
                    "description": "S3 bucket designated for publishing log files."
                },
                "s3KeyPrefix": {
                    "type": "string",
                    "description": "S3 key prefix that follows the name of the bucket you have designated for log file delivery.\n"
                },
                "snsTopicName": {
                    "type": "string",
                    "description": "Name of the Amazon SNS topic defined for notification of log file delivery.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of tags to assign to the trail. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                }
            },
            "isComponent": true
        },
        "awsx:ec2:DefaultVpc": {
            "description": "Pseudo resource representing the default VPC and associated subnets for an account and region. This does not create any resources. This will be replaced with `getDefaultVpc` in the future.",
            "properties": {
                "privateSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "publicSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "vpcId": {
                    "type": "string",
                    "description": "The VPC ID for the default VPC"
                }
            },
            "required": [
                "vpcId",
                "publicSubnetIds",
                "privateSubnetIds"
            ],
            "isComponent": true
        },
        "awsx:ec2:Vpc": {
            "description": "The VPC component provides a VPC with configured subnets and NAT gateways.\n\n{{% examples %}}\n\n## Example Usage\n\n{{% example %}}\n\nBasic usage:\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as awsx from \"@pulumi/awsx\";\n\nconst vpc = new awsx.ec2.Vpc(\"vpc\", {});\nexport const vpcId = vpc.vpcId;\nexport const vpcPrivateSubnetIds = vpc.privateSubnetIds;\nexport const vpcPublicSubnetIds = vpc.publicSubnetIds;\n```\n\n```python\nimport pulumi\nimport pulumi_awsx as awsx\n\nvpc = awsx.ec2.Vpc(\"vpc\")\npulumi.export(\"vpcId\", vpc.vpc_id)\npulumi.export(\"vpcPrivateSubnetIds\", vpc.private_subnet_ids)\npulumi.export(\"vpcPublicSubnetIds\", vpc.public_subnet_ids)\n```\n\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Awsx = Pulumi.Awsx;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var vpc = new Awsx.Ec2.Vpc(\"vpc\");\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"vpcId\"] = vpc.VpcId,\n        [\"vpcPrivateSubnetIds\"] = vpc.PrivateSubnetIds,\n        [\"vpcPublicSubnetIds\"] = vpc.PublicSubnetIds,\n    };\n});\n```\n\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-awsx/sdk/v2/go/awsx/ec2\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tvpc, err := ec2.NewVpc(ctx, \"vpc\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"vpcId\", vpc.VpcId)\n\t\tctx.Export(\"vpcPrivateSubnetIds\", vpc.PrivateSubnetIds)\n\t\tctx.Export(\"vpcPublicSubnetIds\", vpc.PublicSubnetIds)\n\t\treturn nil\n\t})\n}\n```\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.awsx.ec2.Vpc;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var vpc = new Vpc(\"vpc\");\n\n        ctx.export(\"vpcId\", vpc.vpcId());\n        ctx.export(\"vpcPrivateSubnetIds\", vpc.privateSubnetIds());\n        ctx.export(\"vpcPublicSubnetIds\", vpc.publicSubnetIds());\n    }\n}\n```\n\n```yaml\nresources:\n  vpc:\n    type: awsx:ec2:Vpc\noutputs:\n  vpcId: ${vpc.vpcId}\n  vpcPrivateSubnetIds: ${vpc.privateSubnetIds}\n  vpcPublicSubnetIds: ${vpc.publicSubnetIds}\n```\n\n{{% /example %}}\n{{% /examples %}}\n\n## Subnet Layout Strategies\n\nIf no subnet arguments are passed, then a public and private subnet will be created in each AZ with default sizing. The layout of these subnets can be customised by specifying additional arguments.\n\nAll strategies are designed to help build a uniform layout of subnets each each availability zone.\n\nIf no strategy is specified, \"Legacy\" will be used for backward compatibility reasons. In the next major version this will change to defaulting to \"Auto\".\n\n### Auto\n\nThe \"Auto\" strategy divides the VPC space evenly between the availability zones. Within each availability zone it allocates each subnet in the order they were specified. If a CIDR mask or size was not specified it will default to an even division of the availability zone range. If subnets have different sizes, spaces will be automatically added to ensure subnets don't overlap (e.g. where a previous subnet is smaller than the next).\n\n### Exact\n\nThe \"Exact\" strategy is the same as \"Auto\" with the additional requirement to explicitly specify what the whole of each zone's range will be used for. Where you expect to have a gap between or after subnets, these must be passed using the subnet specification type \"Unused\" to show all space has been properly accounted for.\n\n### Explicit CIDR Blocks\n\nIf you prefer to do your CIDR block calculations yourself, you can specify a list of CIDR blocks for each subnet spec which it will be allocated for in each availability zone. If using explicit layouts, all subnet specs must be declared with explicit CIDR blocks. Each list of CIDR blocks must have the same length as the number of availability zones for the VPC.\n\n### Legacy\n\nThe \"Legacy\" works similarly to the \"Auto\" strategy except that within each availability zone it allocates the private subnet first, followed by the public subnets, and lastly the isolated subnets. The order of subnet specifications of the same type can be changed, but the ordering of private, public, isolated is not overridable. For more flexibility we recommend moving to the \"Auto\" strategy. The output property `subnetLayout` shows the configuration required if specifying the \"Auto\" strategy to maintain the current layout.\n",
            "properties": {
                "eips": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2feip:Eip"
                    },
                    "description": "The EIPs for any NAT Gateways for the VPC. If no NAT Gateways are specified, this will be an empty list."
                },
                "internetGateway": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2finternetGateway:InternetGateway",
                    "description": "The Internet Gateway for the VPC."
                },
                "isolatedSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "natGateways": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fnatGateway:NatGateway"
                    },
                    "description": "The NAT Gateways for the VPC. If no NAT Gateways are specified, this will be an empty list."
                },
                "privateSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "publicSubnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "routeTableAssociations": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2frouteTableAssociation:RouteTableAssociation"
                    },
                    "description": "The Route Table Associations for the VPC."
                },
                "routeTables": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2frouteTable:RouteTable"
                    },
                    "description": "The Route Tables for the VPC."
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2froute:Route"
                    },
                    "description": "The Routes for the VPC."
                },
                "subnetLayout": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ec2:ResolvedSubnetSpec"
                    },
                    "description": "The resolved subnet specs layout deployed to each availability zone."
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fsubnet:Subnet"
                    },
                    "description": "The VPC's subnets."
                },
                "vpc": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fvpc:Vpc",
                    "description": "The VPC.",
                    "language": {
                        "csharp": {
                            "name": "AwsVpc"
                        }
                    }
                },
                "vpcEndpoints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fvpcEndpoint:VpcEndpoint"
                    },
                    "description": "The VPC Endpoints that are enabled"
                },
                "vpcId": {
                    "type": "string"
                }
            },
            "required": [
                "vpc",
                "subnets",
                "routeTables",
                "routeTableAssociations",
                "routes",
                "internetGateway",
                "natGateways",
                "eips",
                "subnetLayout",
                "publicSubnetIds",
                "privateSubnetIds",
                "isolatedSubnetIds",
                "vpcId",
                "vpcEndpoints"
            ],
            "inputProperties": {
                "assignGeneratedIpv6CidrBlock": {
                    "type": "boolean",
                    "description": "Requests an Amazon-provided IPv6 CIDR block with a /56 prefix length for the VPC. You cannot specify the range of IP addresses, or the size of the CIDR block. Default is `false`. Conflicts with `ipv6_ipam_pool_id`\n"
                },
                "availabilityZoneCidrMask": {
                    "type": "integer",
                    "plain": true,
                    "description": "The netmask for each available zone to be aligned to. This is optional, the default value is inferred based on an even distribution of available space from the VPC's CIDR block after being divided evenly by the number of availability zones."
                },
                "availabilityZoneNames": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "plain": true
                    },
                    "plain": true,
                    "description": "A list of availability zone names to which the subnets defined in subnetSpecs will be deployed. Optional, defaults to the first 3 AZs in the current region."
                },
                "cidrBlock": {
                    "type": "string",
                    "plain": true,
                    "description": "The CIDR block for the VPC. Optional. Defaults to 10.0.0.0/16."
                },
                "enableDnsHostnames": {
                    "type": "boolean",
                    "description": "A boolean flag to enable/disable DNS hostnames in the VPC. Defaults false.\n"
                },
                "enableDnsSupport": {
                    "type": "boolean",
                    "description": "A boolean flag to enable/disable DNS support in the VPC. Defaults to true.\n"
                },
                "enableNetworkAddressUsageMetrics": {
                    "type": "boolean",
                    "description": "Indicates whether Network Address Usage metrics are enabled for your VPC. Defaults to false.\n"
                },
                "instanceTenancy": {
                    "type": "string",
                    "description": "A tenancy option for instances launched into the VPC. Default is `default`, which ensures that EC2 instances launched in this VPC use the EC2 instance tenancy attribute specified when the EC2 instance is launched. The only other option is `dedicated`, which ensures that EC2 instances launched in this VPC are run on dedicated tenancy instances regardless of the tenancy attribute specified at launch. This has a dedicated per region fee of $2 per hour, plus an hourly per instance usage fee.\n"
                },
                "ipv4IpamPoolId": {
                    "type": "string",
                    "description": "The ID of an IPv4 IPAM pool you want to use for allocating this VPC's CIDR. IPAM is a VPC feature that you can use to automate your IP address management workflows including assigning, tracking, troubleshooting, and auditing IP addresses across AWS Regions and accounts. Using IPAM you can monitor IP address usage throughout your AWS Organization.\n",
                    "willReplaceOnChanges": true
                },
                "ipv4NetmaskLength": {
                    "type": "integer",
                    "description": "The netmask length of the IPv4 CIDR you want to allocate to this VPC. Requires specifying a `ipv4_ipam_pool_id`.\n",
                    "willReplaceOnChanges": true
                },
                "ipv6CidrBlock": {
                    "type": "string",
                    "description": "IPv6 CIDR block to request from an IPAM Pool. Can be set explicitly or derived from IPAM using `ipv6_netmask_length`.\n"
                },
                "ipv6CidrBlockNetworkBorderGroup": {
                    "type": "string",
                    "description": "By default when an IPv6 CIDR is assigned to a VPC a default ipv6_cidr_block_network_border_group will be set to the region of the VPC. This can be changed to restrict advertisement of public addresses to specific Network Border Groups such as LocalZones.\n"
                },
                "ipv6IpamPoolId": {
                    "type": "string",
                    "description": "IPAM Pool ID for a IPv6 pool. Conflicts with `assign_generated_ipv6_cidr_block`.\n"
                },
                "ipv6NetmaskLength": {
                    "type": "integer",
                    "description": "Netmask length to request from IPAM Pool. Conflicts with `ipv6_cidr_block`. This can be omitted if IPAM pool as a `allocation_default_netmask_length` set. Valid values: `56`.\n"
                },
                "natGateways": {
                    "$ref": "#/types/awsx:ec2:NatGatewayConfiguration",
                    "plain": true,
                    "description": "Configuration for NAT Gateways. Optional. If private and public subnets are both specified, defaults to one gateway per availability zone. Otherwise, no gateways will be created."
                },
                "numberOfAvailabilityZones": {
                    "type": "integer",
                    "plain": true,
                    "description": "A number of availability zones to which the subnets defined in subnetSpecs will be deployed. Optional, defaults to the first 3 AZs in the current region."
                },
                "subnetSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ec2:SubnetSpec",
                        "plain": true
                    },
                    "plain": true,
                    "description": "A list of subnet specs that should be deployed to each AZ specified in availabilityZoneNames. Optional. Defaults to a (smaller) public subnet and a (larger) private subnet based on the size of the CIDR block for the VPC. Private subnets are allocated CIDR block ranges first, followed by Private subnets, and Isolated subnets are allocated last."
                },
                "subnetStrategy": {
                    "$ref": "#/types/awsx:ec2:SubnetAllocationStrategy",
                    "plain": true,
                    "description": "The strategy to use when allocating subnets for the VPC. Optional. Defaults to `Legacy`."
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "vpcEndpointSpecs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:ec2:VpcEndpointSpec",
                        "plain": true
                    },
                    "plain": true,
                    "description": "A list of VPC Endpoints specs to be deployed as part of the VPC"
                }
            },
            "isComponent": true
        },
        "awsx:ecr:Image": {
            "description": "Builds a docker image and pushes to the ECR repository",
            "properties": {
                "imageUri": {
                    "type": "string",
                    "description": "Unique identifier of the pushed image"
                }
            },
            "type": "object",
            "required": [
                "imageUri"
            ],
            "inputProperties": {
                "args": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "An optional map of named build-time argument variables to set during the Docker build.  This flag allows you to pass built-time variables that can be accessed like environment variables inside the `RUN` instruction."
                },
                "builderVersion": {
                    "$ref": "#/types/awsx:ecr:BuilderVersion",
                    "plain": true,
                    "description": "The version of the Docker builder."
                },
                "cacheFrom": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Images to consider as cache sources"
                },
                "context": {
                    "type": "string",
                    "description": "Path to a directory to use for the Docker build context, usually the directory in which the Dockerfile resides (although dockerfile may be used to choose a custom location independent of this choice). If not specified, the context defaults to the current working directory; if a relative path is used, it is relative to the current working directory that Pulumi is evaluating."
                },
                "dockerfile": {
                    "type": "string",
                    "description": "dockerfile may be used to override the default Dockerfile name and/or location.  By default, it is assumed to be a file named Dockerfile in the root of the build context."
                },
                "imageName": {
                    "type": "string",
                    "description": "Custom name for the underlying Docker image resource. If omitted, the image tag assigned by the provider will be used"
                },
                "imageTag": {
                    "type": "string",
                    "description": "Custom image tag for the resulting docker image. If omitted a random string will be used"
                },
                "platform": {
                    "type": "string",
                    "description": "The architecture of the platform you want to build this image for, e.g. `linux/arm64`."
                },
                "registryId": {
                    "type": "string",
                    "description": "ID of the ECR registry in which to store the image.  If not provided, this will be inferred from the repository URL)"
                },
                "repositoryUrl": {
                    "type": "string",
                    "description": "Url of the repository"
                },
                "target": {
                    "type": "string",
                    "description": "The target of the dockerfile to build"
                }
            },
            "requiredInputs": [
                "repositoryUrl"
            ],
            "isComponent": true
        },
        "awsx:ecr:Repository": {
            "description": "A [Repository] represents an [aws.ecr.Repository] along with an associated [LifecyclePolicy] controlling how images are retained in the repo. \n\nDocker images can be built and pushed to the repo using the [buildAndPushImage] method.  This will call into the `@pulumi/docker/buildAndPushImage` function using this repo as the appropriate destination registry.",
            "properties": {
                "lifecyclePolicy": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecr%2flifecyclePolicy:LifecyclePolicy",
                    "description": "Underlying repository lifecycle policy"
                },
                "repository": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecr%2frepository:Repository",
                    "description": "Underlying Repository resource",
                    "language": {
                        "csharp": {
                            "name": "AwsRepository"
                        }
                    }
                },
                "url": {
                    "type": "string",
                    "description": "The URL of the repository (in the form aws_account_id.dkr.ecr.region.amazonaws.com/repositoryName).\n"
                }
            },
            "type": "object",
            "required": [
                "repository",
                "url"
            ],
            "inputProperties": {
                "encryptionConfigurations": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecr/RepositoryEncryptionConfiguration:RepositoryEncryptionConfiguration"
                    },
                    "description": "Encryption configuration for the repository. See below for schema.\n",
                    "willReplaceOnChanges": true
                },
                "forceDelete": {
                    "type": "boolean",
                    "description": "If `true`, will delete the repository even if it contains images.\nDefaults to `false`.\n"
                },
                "imageScanningConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecr/RepositoryImageScanningConfiguration:RepositoryImageScanningConfiguration",
                    "description": "Configuration block that defines image scanning configuration for the repository. By default, image scanning must be manually triggered. See the [ECR User Guide](https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html) for more information about image scanning.\n"
                },
                "imageTagMutability": {
                    "type": "string",
                    "description": "The tag mutability setting for the repository. Must be one of: `MUTABLE` or `IMMUTABLE`. Defaults to `MUTABLE`.\n"
                },
                "lifecyclePolicy": {
                    "$ref": "#/types/awsx:ecr:lifecyclePolicy",
                    "plain": true,
                    "description": "A lifecycle policy consists of one or more rules that determine which images in a repository should be expired. If not provided, this will default to untagged images expiring after 1 day."
                },
                "name": {
                    "type": "string",
                    "description": "Name of the repository.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                }
            },
            "isComponent": true
        },
        "awsx:ecs:EC2Service": {
            "description": "Create an ECS Service resource for EC2 with the given unique name, arguments, and options.\nCreates Task definition if `taskDefinitionArgs` is specified.",
            "properties": {
                "service": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecs%2fservice:Service",
                    "description": "Underlying ECS Service resource"
                },
                "taskDefinition": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecs%2FtaskDefinition:TaskDefinition",
                    "description": "Underlying EC2 Task definition component resource if created from args"
                }
            },
            "required": [
                "service"
            ],
            "inputProperties": {
                "alarms": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceAlarms:ServiceAlarms",
                    "description": "Information about the CloudWatch alarms. See below.\n"
                },
                "cluster": {
                    "type": "string",
                    "description": "ARN of an ECS cluster.\n",
                    "willReplaceOnChanges": true
                },
                "continueBeforeSteadyState": {
                    "type": "boolean",
                    "description": "If `true`, this provider will not wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`."
                },
                "deploymentCircuitBreaker": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceDeploymentCircuitBreaker:ServiceDeploymentCircuitBreaker",
                    "description": "Configuration block for deployment circuit breaker. See below.\n"
                },
                "deploymentController": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceDeploymentController:ServiceDeploymentController",
                    "description": "Configuration block for deployment controller configuration. See below.\n"
                },
                "deploymentMaximumPercent": {
                    "type": "integer",
                    "description": "Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.\n"
                },
                "deploymentMinimumHealthyPercent": {
                    "type": "integer",
                    "description": "Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.\n"
                },
                "desiredCount": {
                    "type": "integer",
                    "description": "Number of instances of the task definition to place and keep running. Defaults to 0. Do not specify if using the `DAEMON` scheduling strategy.\n"
                },
                "enableEcsManagedTags": {
                    "type": "boolean",
                    "description": "Specifies whether to enable Amazon ECS managed tags for the tasks within the service.\n"
                },
                "enableExecuteCommand": {
                    "type": "boolean",
                    "description": "Specifies whether to enable Amazon ECS Exec for the tasks within the service.\n"
                },
                "forceNewDeployment": {
                    "type": "boolean",
                    "description": "Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., `myimage:latest`), roll Fargate tasks onto a newer platform version, or immediately deploy `ordered_placement_strategy` and `placement_constraints` updates.\n"
                },
                "healthCheckGracePeriodSeconds": {
                    "type": "integer",
                    "description": "Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.\n"
                },
                "iamRole": {
                    "type": "string",
                    "description": "ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.\n",
                    "willReplaceOnChanges": true
                },
                "loadBalancers": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceLoadBalancer:ServiceLoadBalancer"
                    },
                    "description": "Configuration block for load balancers. See below.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service (up to 255 letters, numbers, hyphens, and underscores)\n\nThe following arguments are optional:\n",
                    "willReplaceOnChanges": true
                },
                "networkConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceNetworkConfiguration:ServiceNetworkConfiguration",
                    "description": "Network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.\n"
                },
                "orderedPlacementStrategies": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceOrderedPlacementStrategy:ServiceOrderedPlacementStrategy"
                    },
                    "description": "Service level strategy rules that are taken into consideration during task placement. List from top to bottom in order of precedence. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. The maximum number of `ordered_placement_strategy` blocks is `5`. See below.\n"
                },
                "placementConstraints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServicePlacementConstraint:ServicePlacementConstraint"
                    },
                    "description": "Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. Maximum number of `placement_constraints` is `10`. See below.\n"
                },
                "platformVersion": {
                    "type": "string",
                    "description": "Platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).\n"
                },
                "propagateTags": {
                    "type": "string",
                    "description": "Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.\n"
                },
                "schedulingStrategy": {
                    "type": "string",
                    "description": "Scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Tasks using the Fargate launch type or the `CODE_DEPLOY` or `EXTERNAL` deployment controller types don't support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html).\n",
                    "willReplaceOnChanges": true
                },
                "serviceConnectConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceServiceConnectConfiguration:ServiceServiceConnectConfiguration",
                    "description": "The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.\n"
                },
                "serviceRegistries": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceServiceRegistries:ServiceServiceRegistries",
                    "description": "Service discovery registries for the service. The maximum number of `service_registries` blocks is `1`. See below.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "taskDefinition": {
                    "type": "string",
                    "description": "Family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided."
                },
                "taskDefinitionArgs": {
                    "$ref": "#/types/awsx:ecs:EC2ServiceTaskDefinition",
                    "plain": true,
                    "description": "The args of task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided."
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with `plantimestamp()`. See example above.\n"
                }
            },
            "isComponent": true
        },
        "awsx:ecs:EC2TaskDefinition": {
            "description": "Create a TaskDefinition resource with the given unique name, arguments, and options.\nCreates required log-group and task \u0026 execution roles.\nPresents required Service load balancers if target group included in port mappings.",
            "properties": {
                "executionRole": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:iam%2Frole:Role",
                    "description": "Auto-created IAM task execution role that the Amazon ECS container agent and the Docker daemon can assume."
                },
                "loadBalancers": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs%2FServiceLoadBalancer:ServiceLoadBalancer"
                    },
                    "description": "Computed load balancers from target groups specified of container port mappings."
                },
                "logGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:cloudwatch%2FlogGroup:LogGroup",
                    "description": "Auto-created Log Group resource for use by containers."
                },
                "taskDefinition": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecs%2FtaskDefinition:TaskDefinition",
                    "description": "Underlying ECS Task Definition resource"
                },
                "taskRole": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:iam%2Frole:Role",
                    "description": "Auto-created IAM role that allows your Amazon ECS container task to make calls to other AWS services."
                }
            },
            "required": [
                "taskDefinition",
                "loadBalancers"
            ],
            "inputProperties": {
                "container": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                    "plain": true,
                    "description": "Single container to make a TaskDefinition from.  Useful for simple cases where there aren't\nmultiple containers, especially when creating a TaskDefinition to call [run] on.\n\nEither [container] or [containers] must be provided."
                },
                "containers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                        "plain": true
                    },
                    "plain": true,
                    "description": "All the containers to make a TaskDefinition from.  Useful when creating a Service that will\ncontain many containers within.\n\nEither [container] or [containers] must be provided."
                },
                "cpu": {
                    "type": "string",
                    "description": "The number of cpu units used by the task. If not provided, a default will be computed based on the cumulative needs specified by [containerDefinitions]"
                },
                "ephemeralStorage": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionEphemeralStorage:TaskDefinitionEphemeralStorage",
                    "description": "The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on AWS Fargate. See Ephemeral Storage.\n",
                    "willReplaceOnChanges": true
                },
                "executionRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "The execution role that the Amazon ECS container agent and the Docker daemon can assume.\nWill be created automatically if not defined."
                },
                "family": {
                    "type": "string",
                    "description": "An optional unique name for your task definition. If not specified, then a default will be created."
                },
                "inferenceAccelerators": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionInferenceAccelerator:TaskDefinitionInferenceAccelerator"
                    },
                    "description": "Configuration block(s) with Inference Accelerators settings. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "ipcMode": {
                    "type": "string",
                    "description": "IPC resource namespace to be used for the containers in the task The valid values are `host`, `task`, and `none`.\n",
                    "willReplaceOnChanges": true
                },
                "logGroup": {
                    "$ref": "#/types/awsx:awsx:DefaultLogGroup",
                    "plain": true,
                    "description": "A set of volume blocks that containers in your task may use."
                },
                "memory": {
                    "type": "string",
                    "description": "The amount (in MiB) of memory used by the task.  If not provided, a default will be computed\nbased on the cumulative needs specified by [containerDefinitions]"
                },
                "networkMode": {
                    "type": "string",
                    "description": "Docker networking mode to use for the containers in the task. Valid values are `none`, `bridge`, `awsvpc`, and `host`.\n",
                    "willReplaceOnChanges": true
                },
                "pidMode": {
                    "type": "string",
                    "description": "Process namespace to use for the containers in the task. The valid values are `host` and `task`.\n",
                    "willReplaceOnChanges": true
                },
                "placementConstraints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionPlacementConstraint:TaskDefinitionPlacementConstraint"
                    },
                    "description": "Configuration block for rules that are taken into consideration during task placement. Maximum number of `placement_constraints` is `10`. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "proxyConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionProxyConfiguration:TaskDefinitionProxyConfiguration",
                    "description": "Configuration block for the App Mesh proxy. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "runtimePlatform": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionRuntimePlatform:TaskDefinitionRuntimePlatform",
                    "description": "Configuration block for runtime_platform that containers in your task may use.\n",
                    "willReplaceOnChanges": true
                },
                "skipDestroy": {
                    "type": "boolean",
                    "description": "Whether to retain the old revision when the resource is destroyed or replacement is necessary. Default is `false`.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "taskRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "IAM role that allows your Amazon ECS container task to make calls to other AWS services.\nWill be created automatically if not defined."
                },
                "trackLatest": {
                    "type": "boolean",
                    "description": "Whether should track latest task definition or the one created with the resource. Default is `false`.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionVolume:TaskDefinitionVolume"
                    },
                    "description": "Configuration block for volumes that containers in your task may use. Detailed below.\n",
                    "willReplaceOnChanges": true
                }
            },
            "isComponent": true
        },
        "awsx:ecs:FargateService": {
            "description": "Create an ECS Service resource for Fargate with the given unique name, arguments, and options.\nCreates Task definition if `taskDefinitionArgs` is specified.",
            "properties": {
                "service": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecs%2fservice:Service",
                    "description": "Underlying ECS Service resource"
                },
                "taskDefinition": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecs%2FtaskDefinition:TaskDefinition",
                    "description": "Underlying Fargate component resource if created from args"
                }
            },
            "required": [
                "service"
            ],
            "inputProperties": {
                "alarms": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceAlarms:ServiceAlarms",
                    "description": "Information about the CloudWatch alarms. See below.\n"
                },
                "assignPublicIp": {
                    "type": "boolean",
                    "description": "Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`."
                },
                "cluster": {
                    "type": "string",
                    "description": "ARN of an ECS cluster.\n",
                    "willReplaceOnChanges": true
                },
                "continueBeforeSteadyState": {
                    "type": "boolean",
                    "description": "If `true`, this provider will not wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`."
                },
                "deploymentCircuitBreaker": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceDeploymentCircuitBreaker:ServiceDeploymentCircuitBreaker",
                    "description": "Configuration block for deployment circuit breaker. See below.\n"
                },
                "deploymentController": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceDeploymentController:ServiceDeploymentController",
                    "description": "Configuration block for deployment controller configuration. See below.\n"
                },
                "deploymentMaximumPercent": {
                    "type": "integer",
                    "description": "Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.\n"
                },
                "deploymentMinimumHealthyPercent": {
                    "type": "integer",
                    "description": "Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.\n"
                },
                "desiredCount": {
                    "type": "integer",
                    "description": "Number of instances of the task definition to place and keep running. Defaults to 1. Do not specify if using the `DAEMON` scheduling strategy.\n"
                },
                "enableEcsManagedTags": {
                    "type": "boolean",
                    "description": "Specifies whether to enable Amazon ECS managed tags for the tasks within the service.\n"
                },
                "enableExecuteCommand": {
                    "type": "boolean",
                    "description": "Specifies whether to enable Amazon ECS Exec for the tasks within the service.\n"
                },
                "forceNewDeployment": {
                    "type": "boolean",
                    "description": "Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., `myimage:latest`), roll Fargate tasks onto a newer platform version, or immediately deploy `ordered_placement_strategy` and `placement_constraints` updates.\n"
                },
                "healthCheckGracePeriodSeconds": {
                    "type": "integer",
                    "description": "Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.\n"
                },
                "iamRole": {
                    "type": "string",
                    "description": "ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.\n",
                    "willReplaceOnChanges": true
                },
                "loadBalancers": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceLoadBalancer:ServiceLoadBalancer"
                    },
                    "description": "Configuration block for load balancers. See below.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the service (up to 255 letters, numbers, hyphens, and underscores)\n\nThe following arguments are optional:\n",
                    "willReplaceOnChanges": true
                },
                "networkConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceNetworkConfiguration:ServiceNetworkConfiguration",
                    "description": "Network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.\n"
                },
                "placementConstraints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServicePlacementConstraint:ServicePlacementConstraint"
                    },
                    "description": "Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. Maximum number of `placement_constraints` is `10`. See below.\n"
                },
                "platformVersion": {
                    "type": "string",
                    "description": "Platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).\n"
                },
                "propagateTags": {
                    "type": "string",
                    "description": "Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.\n"
                },
                "schedulingStrategy": {
                    "type": "string",
                    "description": "Scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Tasks using the Fargate launch type or the `CODE_DEPLOY` or `EXTERNAL` deployment controller types don't support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html).\n",
                    "willReplaceOnChanges": true
                },
                "serviceConnectConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceServiceConnectConfiguration:ServiceServiceConnectConfiguration",
                    "description": "The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.\n"
                },
                "serviceRegistries": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/ServiceServiceRegistries:ServiceServiceRegistries",
                    "description": "Service discovery registries for the service. The maximum number of `service_registries` blocks is `1`. See below.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "taskDefinition": {
                    "type": "string",
                    "description": "Family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided."
                },
                "taskDefinitionArgs": {
                    "$ref": "#/types/awsx:ecs:FargateServiceTaskDefinition",
                    "plain": true,
                    "description": "The args of task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided."
                },
                "triggers": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with `plantimestamp()`. See example above.\n"
                }
            },
            "isComponent": true
        },
        "awsx:ecs:FargateTaskDefinition": {
            "description": "Create a TaskDefinition resource with the given unique name, arguments, and options.\nCreates required log-group and task \u0026 execution roles.\nPresents required Service load balancers if target group included in port mappings.",
            "properties": {
                "executionRole": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:iam%2Frole:Role",
                    "description": "Auto-created IAM task execution role that the Amazon ECS container agent and the Docker daemon can assume."
                },
                "loadBalancers": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs%2FServiceLoadBalancer:ServiceLoadBalancer"
                    },
                    "description": "Computed load balancers from target groups specified of container port mappings."
                },
                "logGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:cloudwatch%2FlogGroup:LogGroup",
                    "description": "Auto-created Log Group resource for use by containers."
                },
                "taskDefinition": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ecs%2FtaskDefinition:TaskDefinition",
                    "description": "Underlying ECS Task Definition resource"
                },
                "taskRole": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:iam%2Frole:Role",
                    "description": "Auto-created IAM role that allows your Amazon ECS container task to make calls to other AWS services."
                }
            },
            "required": [
                "taskDefinition",
                "loadBalancers"
            ],
            "inputProperties": {
                "container": {
                    "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                    "plain": true,
                    "description": "Single container to make a TaskDefinition from.  Useful for simple cases where there aren't\nmultiple containers, especially when creating a TaskDefinition to call [run] on.\n\nEither [container] or [containers] must be provided."
                },
                "containers": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "#/types/awsx:ecs:TaskDefinitionContainerDefinition",
                        "plain": true
                    },
                    "plain": true,
                    "description": "All the containers to make a TaskDefinition from.  Useful when creating a Service that will\ncontain many containers within.\n\nEither [container] or [containers] must be provided."
                },
                "cpu": {
                    "type": "string",
                    "description": "The number of cpu units used by the task. If not provided, a default will be computed based on the cumulative needs specified by [containerDefinitions]"
                },
                "ephemeralStorage": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionEphemeralStorage:TaskDefinitionEphemeralStorage",
                    "description": "The amount of ephemeral storage to allocate for the task. This parameter is used to expand the total amount of ephemeral storage available, beyond the default amount, for tasks hosted on AWS Fargate. See Ephemeral Storage.\n",
                    "willReplaceOnChanges": true
                },
                "executionRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "The execution role that the Amazon ECS container agent and the Docker daemon can assume.\nWill be created automatically if not defined."
                },
                "family": {
                    "type": "string",
                    "description": "An optional unique name for your task definition. If not specified, then a default will be created."
                },
                "inferenceAccelerators": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionInferenceAccelerator:TaskDefinitionInferenceAccelerator"
                    },
                    "description": "Configuration block(s) with Inference Accelerators settings. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "ipcMode": {
                    "type": "string",
                    "description": "IPC resource namespace to be used for the containers in the task The valid values are `host`, `task`, and `none`.\n",
                    "willReplaceOnChanges": true
                },
                "logGroup": {
                    "$ref": "#/types/awsx:awsx:DefaultLogGroup",
                    "plain": true,
                    "description": "A set of volume blocks that containers in your task may use."
                },
                "memory": {
                    "type": "string",
                    "description": "The amount (in MiB) of memory used by the task.  If not provided, a default will be computed\nbased on the cumulative needs specified by [containerDefinitions]"
                },
                "pidMode": {
                    "type": "string",
                    "description": "Process namespace to use for the containers in the task. The valid values are `host` and `task`.\n",
                    "willReplaceOnChanges": true
                },
                "placementConstraints": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionPlacementConstraint:TaskDefinitionPlacementConstraint"
                    },
                    "description": "Configuration block for rules that are taken into consideration during task placement. Maximum number of `placement_constraints` is `10`. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "proxyConfiguration": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionProxyConfiguration:TaskDefinitionProxyConfiguration",
                    "description": "Configuration block for the App Mesh proxy. Detailed below.\n",
                    "willReplaceOnChanges": true
                },
                "runtimePlatform": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionRuntimePlatform:TaskDefinitionRuntimePlatform",
                    "description": "Configuration block for runtime_platform that containers in your task may use.\n",
                    "willReplaceOnChanges": true
                },
                "skipDestroy": {
                    "type": "boolean",
                    "description": "Whether to retain the old revision when the resource is destroyed or replacement is necessary. Default is `false`.\n"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "taskRole": {
                    "$ref": "#/types/awsx:awsx:DefaultRoleWithPolicy",
                    "plain": true,
                    "description": "IAM role that allows your Amazon ECS container task to make calls to other AWS services.\nWill be created automatically if not defined."
                },
                "trackLatest": {
                    "type": "boolean",
                    "description": "Whether should track latest task definition or the one created with the resource. Default is `false`.\n"
                },
                "volumes": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:ecs/TaskDefinitionVolume:TaskDefinitionVolume"
                    },
                    "description": "Configuration block for volumes that containers in your task may use. Detailed below.\n",
                    "willReplaceOnChanges": true
                }
            },
            "isComponent": true
        },
        "awsx:lb:ApplicationLoadBalancer": {
            "description": "Provides an Application Load Balancer resource with listeners, default target group and default security group.",
            "properties": {
                "defaultSecurityGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fsecurityGroup:SecurityGroup",
                    "description": "Default security group, if auto-created"
                },
                "defaultTargetGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2ftargetGroup:TargetGroup",
                    "description": "Default target group, if auto-created"
                },
                "listeners": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2flistener:Listener"
                    },
                    "description": "Listeners created as part of this load balancer"
                },
                "loadBalancer": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2floadBalancer:LoadBalancer",
                    "description": "Underlying Load Balancer resource"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Id of the VPC in which this load balancer is operating"
                }
            },
            "type": "object",
            "required": [
                "loadBalancer",
                "defaultTargetGroup"
            ],
            "inputProperties": {
                "accessLogs": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/LoadBalancerAccessLogs:LoadBalancerAccessLogs",
                    "description": "Access Logs block. See below.\n"
                },
                "clientKeepAlive": {
                    "type": "integer",
                    "description": "Client keep alive value in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.\n"
                },
                "connectionLogs": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/LoadBalancerConnectionLogs:LoadBalancerConnectionLogs",
                    "description": "Connection Logs block. See below. Only valid for Load Balancers of type `application`.\n"
                },
                "customerOwnedIpv4Pool": {
                    "type": "string",
                    "description": "ID of the customer owned ipv4 pool to use for this load balancer.\n",
                    "willReplaceOnChanges": true
                },
                "defaultSecurityGroup": {
                    "$ref": "#/types/awsx:awsx:DefaultSecurityGroup",
                    "plain": true,
                    "description": "Options for creating a default security group if [securityGroups] not specified."
                },
                "defaultTargetGroup": {
                    "$ref": "#/types/awsx:lb:TargetGroup",
                    "plain": true,
                    "description": "Options creating a default target group."
                },
                "defaultTargetGroupPort": {
                    "type": "integer",
                    "description": "Port to use to connect with the target. Valid values are ports 1-65535. Defaults to 80.\n"
                },
                "desyncMitigationMode": {
                    "type": "string",
                    "description": "How the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are `monitor`, `defensive` (default), `strictest`.\n"
                },
                "dnsRecordClientRoutingPolicy": {
                    "type": "string",
                    "description": "How traffic is distributed among the load balancer Availability Zones. Possible values are `any_availability_zone` (default), `availability_zone_affinity`, or `partial_availability_zone_affinity`. See   [Availability Zone DNS affinity](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#zonal-dns-affinity) for additional details. Only valid for `network` type load balancers.\n"
                },
                "dropInvalidHeaderFields": {
                    "type": "boolean",
                    "description": "Whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type `application`.\n"
                },
                "enableDeletionProtection": {
                    "type": "boolean",
                    "description": "If true, deletion of the load balancer will be disabled via the AWS API. This will prevent this provider from deleting the load balancer. Defaults to `false`.\n"
                },
                "enableHttp2": {
                    "type": "boolean",
                    "description": "Whether HTTP/2 is enabled in `application` load balancers. Defaults to `true`.\n"
                },
                "enableTlsVersionAndCipherSuiteHeaders": {
                    "type": "boolean",
                    "description": "Whether the two headers (`x-amzn-tls-version` and `x-amzn-tls-cipher-suite`), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. Only valid for Load Balancers of type `application`. Defaults to `false`\n"
                },
                "enableWafFailOpen": {
                    "type": "boolean",
                    "description": "Whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to `false`.\n"
                },
                "enableXffClientPort": {
                    "type": "boolean",
                    "description": "Whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer in `application` load balancers. Defaults to `false`.\n"
                },
                "enforceSecurityGroupInboundRulesOnPrivateLinkTraffic": {
                    "type": "string",
                    "description": "Whether inbound security group rules are enforced for traffic originating from a PrivateLink. Only valid for Load Balancers of type `network`. The possible values are `on` and `off`.\n"
                },
                "idleTimeout": {
                    "type": "integer",
                    "description": "Time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`. Default: 60.\n"
                },
                "internal": {
                    "type": "boolean",
                    "description": "If true, the LB will be internal. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddressType": {
                    "type": "string",
                    "description": "Type of IP addresses used by the subnets for your load balancer. The possible values are `ipv4` and `dualstack`.\n"
                },
                "listener": {
                    "$ref": "#/types/awsx:lb:Listener",
                    "plain": true,
                    "description": "A listener to create. Only one of [listener] and [listeners] can be specified."
                },
                "listeners": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:lb:Listener",
                        "plain": true
                    },
                    "plain": true,
                    "description": "List of listeners to create. Only one of [listener] and [listeners] can be specified."
                },
                "name": {
                    "type": "string",
                    "description": "Name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. If not specified, this provider will autogenerate a name beginning with `tf-lb`.\n",
                    "willReplaceOnChanges": true
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique name beginning with the specified prefix. Conflicts with `name`.\n",
                    "willReplaceOnChanges": true
                },
                "preserveHostHeader": {
                    "type": "boolean",
                    "description": "Whether the Application Load Balancer should preserve the Host header in the HTTP request and send it to the target without any change. Defaults to `false`.\n"
                },
                "securityGroups": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of security group IDs to assign to the LB. Only valid for Load Balancers of type `application` or `network`. For load balancers of type `network` security groups cannot be added if none are currently present, and cannot all be removed once added. If either of these conditions are met, this will force a recreation of the resource.\n"
                },
                "subnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of subnet IDs to attach to the LB. For Load Balancers of type `network` subnets can only be added (see [Availability Zones](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#availability-zones)), deleting a subnet for load balancers of type `network` will force a recreation of the resource.\n"
                },
                "subnetMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/LoadBalancerSubnetMapping:LoadBalancerSubnetMapping"
                    },
                    "description": "Subnet mapping block. See below. For Load Balancers of type `network` subnet mappings can only be added.\n"
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fsubnet:Subnet"
                    },
                    "description": "A list of subnets to attach to the LB. Only one of [subnets], [subnetIds] or [subnetMappings] can be specified"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "xffHeaderProcessingMode": {
                    "type": "string",
                    "description": "Determines how the load balancer modifies the `X-Forwarded-For` header in the HTTP request before sending the request to the target. The possible values are `append`, `preserve`, and `remove`. Only valid for Load Balancers of type `application`. The default is `append`.\n"
                }
            },
            "isComponent": true
        },
        "awsx:lb:NetworkLoadBalancer": {
            "description": "Provides a Network Load Balancer resource with listeners and default target group.",
            "properties": {
                "defaultTargetGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2ftargetGroup:TargetGroup",
                    "description": "Default target group, if auto-created"
                },
                "listeners": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2flistener:Listener"
                    },
                    "description": "Listeners created as part of this load balancer"
                },
                "loadBalancer": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2floadBalancer:LoadBalancer",
                    "description": "Underlying Load Balancer resource"
                },
                "vpcId": {
                    "type": "string",
                    "description": "Id of the VPC in which this load balancer is operating"
                }
            },
            "type": "object",
            "required": [
                "loadBalancer",
                "defaultTargetGroup"
            ],
            "inputProperties": {
                "accessLogs": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/LoadBalancerAccessLogs:LoadBalancerAccessLogs",
                    "description": "Access Logs block. See below.\n"
                },
                "clientKeepAlive": {
                    "type": "integer",
                    "description": "Client keep alive value in seconds. The valid range is 60-604800 seconds. The default is 3600 seconds.\n"
                },
                "connectionLogs": {
                    "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/LoadBalancerConnectionLogs:LoadBalancerConnectionLogs",
                    "description": "Connection Logs block. See below. Only valid for Load Balancers of type `application`.\n"
                },
                "customerOwnedIpv4Pool": {
                    "type": "string",
                    "description": "ID of the customer owned ipv4 pool to use for this load balancer.\n",
                    "willReplaceOnChanges": true
                },
                "defaultTargetGroup": {
                    "$ref": "#/types/awsx:lb:TargetGroup",
                    "plain": true,
                    "description": "Options creating a default target group."
                },
                "defaultTargetGroupPort": {
                    "type": "integer",
                    "description": "Port to use to connect with the target. Valid values are ports 1-65535. Defaults to 80.\n"
                },
                "desyncMitigationMode": {
                    "type": "string",
                    "description": "How the load balancer handles requests that might pose a security risk to an application due to HTTP desync. Valid values are `monitor`, `defensive` (default), `strictest`.\n"
                },
                "dnsRecordClientRoutingPolicy": {
                    "type": "string",
                    "description": "How traffic is distributed among the load balancer Availability Zones. Possible values are `any_availability_zone` (default), `availability_zone_affinity`, or `partial_availability_zone_affinity`. See   [Availability Zone DNS affinity](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#zonal-dns-affinity) for additional details. Only valid for `network` type load balancers.\n"
                },
                "dropInvalidHeaderFields": {
                    "type": "boolean",
                    "description": "Whether HTTP headers with header fields that are not valid are removed by the load balancer (true) or routed to targets (false). The default is false. Elastic Load Balancing requires that message header names contain only alphanumeric characters and hyphens. Only valid for Load Balancers of type `application`.\n"
                },
                "enableCrossZoneLoadBalancing": {
                    "type": "boolean",
                    "description": "If true, cross-zone load balancing of the load balancer will be enabled. For `network` and `gateway` type load balancers, this feature is disabled by default (`false`). For `application` load balancer this feature is always enabled (`true`) and cannot be disabled. Defaults to `false`.\n"
                },
                "enableDeletionProtection": {
                    "type": "boolean",
                    "description": "If true, deletion of the load balancer will be disabled via the AWS API. This will prevent this provider from deleting the load balancer. Defaults to `false`.\n"
                },
                "enableTlsVersionAndCipherSuiteHeaders": {
                    "type": "boolean",
                    "description": "Whether the two headers (`x-amzn-tls-version` and `x-amzn-tls-cipher-suite`), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. Only valid for Load Balancers of type `application`. Defaults to `false`\n"
                },
                "enableWafFailOpen": {
                    "type": "boolean",
                    "description": "Whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Defaults to `false`.\n"
                },
                "enableXffClientPort": {
                    "type": "boolean",
                    "description": "Whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer in `application` load balancers. Defaults to `false`.\n"
                },
                "enforceSecurityGroupInboundRulesOnPrivateLinkTraffic": {
                    "type": "string",
                    "description": "Whether inbound security group rules are enforced for traffic originating from a PrivateLink. Only valid for Load Balancers of type `network`. The possible values are `on` and `off`.\n"
                },
                "idleTimeout": {
                    "type": "integer",
                    "description": "Time in seconds that the connection is allowed to be idle. Only valid for Load Balancers of type `application`. Default: 60.\n"
                },
                "internal": {
                    "type": "boolean",
                    "description": "If true, the LB will be internal. Defaults to `false`.\n",
                    "willReplaceOnChanges": true
                },
                "ipAddressType": {
                    "type": "string",
                    "description": "Type of IP addresses used by the subnets for your load balancer. The possible values are `ipv4` and `dualstack`.\n"
                },
                "listener": {
                    "$ref": "#/types/awsx:lb:Listener",
                    "plain": true,
                    "description": "A listener to create. Only one of [listener] and [listeners] can be specified."
                },
                "listeners": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/awsx:lb:Listener",
                        "plain": true
                    },
                    "plain": true,
                    "description": "List of listeners to create. Only one of [listener] and [listeners] can be specified."
                },
                "name": {
                    "type": "string",
                    "description": "Name of the LB. This name must be unique within your AWS account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. If not specified, this provider will autogenerate a name beginning with `tf-lb`.\n",
                    "willReplaceOnChanges": true
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Creates a unique name beginning with the specified prefix. Conflicts with `name`.\n",
                    "willReplaceOnChanges": true
                },
                "preserveHostHeader": {
                    "type": "boolean",
                    "description": "Whether the Application Load Balancer should preserve the Host header in the HTTP request and send it to the target without any change. Defaults to `false`.\n"
                },
                "subnetIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of subnet IDs to attach to the LB. For Load Balancers of type `network` subnets can only be added (see [Availability Zones](https://docs.aws.amazon.com/elasticloadbalancing/latest/network/network-load-balancers.html#availability-zones)), deleting a subnet for load balancers of type `network` will force a recreation of the resource.\n"
                },
                "subnetMappings": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/types/aws:lb/LoadBalancerSubnetMapping:LoadBalancerSubnetMapping"
                    },
                    "description": "Subnet mapping block. See below. For Load Balancers of type `network` subnet mappings can only be added.\n"
                },
                "subnets": {
                    "type": "array",
                    "items": {
                        "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2fsubnet:Subnet"
                    },
                    "description": "A list of subnets to attach to the LB. Only one of [subnets], [subnetIds] or [subnetMappings] can be specified"
                },
                "tags": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of tags to assign to the resource. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.\n"
                },
                "xffHeaderProcessingMode": {
                    "type": "string",
                    "description": "Determines how the load balancer modifies the `X-Forwarded-For` header in the HTTP request before sending the request to the target. The possible values are `append`, `preserve`, and `remove`. Only valid for Load Balancers of type `application`. The default is `append`.\n"
                }
            },
            "isComponent": true
        },
        "awsx:lb:TargetGroupAttachment": {
            "description": "Attach an EC2 instance or Lambda to a Load Balancer. This will create required permissions if attaching to a Lambda Function.",
            "properties": {
                "lambdaPermission": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lambda%2fpermission:Permission",
                    "description": "Auto-created Lambda permission, if targeting a Lambda function"
                },
                "targetGroupAttachment": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2ftargetGroupAttachment:TargetGroupAttachment",
                    "description": "Underlying Target Group Attachment resource",
                    "language": {
                        "csharp": {
                            "name": "Attachment"
                        }
                    }
                }
            },
            "type": "object",
            "required": [
                "targetGroupAttachment"
            ],
            "inputProperties": {
                "instance": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:ec2%2finstance:Instance",
                    "description": "EC2 Instance to attach to the Target Group. Exactly 1 of [instance], [instanceId], [lambda] or [lambdaArn] must be provided."
                },
                "instanceId": {
                    "type": "string",
                    "description": "ID of an EC2 Instance to attach to the Target Group. Exactly 1 of [instance], [instanceId], [lambda] or [lambdaArn] must be provided."
                },
                "lambda": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lambda%2ffunction:Function",
                    "description": "Lambda Function to attach to the Target Group. Exactly 1 of [instance], [instanceId], [lambda] or [lambdaArn] must be provided.",
                    "language": {
                        "python": {
                            "name": "function"
                        }
                    }
                },
                "lambdaArn": {
                    "type": "string",
                    "description": "ARN of a Lambda Function to attach to the Target Group. Exactly 1 of [instance], [instanceId], [lambda] or [lambdaArn] must be provided."
                },
                "targetGroup": {
                    "$ref": "/aws/v6.32.0/schema.json#/resources/aws:lb%2ftargetGroup:TargetGroup",
                    "description": "Target Group to attach to. Exactly one of [targetGroup] or [targetGroupArn] must be specified."
                },
                "targetGroupArn": {
                    "type": "string",
                    "description": "ARN of the Target Group to attach to. Exactly one of [targetGroup] or [targetGroupArn] must be specified."
                }
            },
            "isComponent": true
        }
    },
    "functions": {
        "awsx:ec2:getDefaultVpc": {
            "deprecationMessage": "Waiting for https://github.com/pulumi/pulumi/issues/7583. Use the DefaultVpc resource until resolved.",
            "description": "[NOT YET IMPLEMENTED] Get the Default VPC for a region.",
            "inputs": {
                "description": "Arguments for getting the default VPC"
            },
            "outputs": {
                "description": "Outputs from the default VPC configuration",
                "properties": {
                    "privateSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "publicSubnetIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "vpcId": {
                        "type": "string",
                        "description": "The VPC ID for the default VPC"
                    }
                },
                "required": [
                    "vpcId",
                    "publicSubnetIds",
                    "privateSubnetIds"
                ]
            }
        }
    }
}