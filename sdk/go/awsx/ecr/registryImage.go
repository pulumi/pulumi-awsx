// Code generated by pulumi-gen-awsx DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ecr

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-awsx/sdk/v3/go/awsx/internal"
	"github.com/pulumi/pulumi-docker/sdk/v4/go/docker"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages the lifecycle of a docker image in a registry. You can upload images to a registry (= `docker push`) and also delete them again. In contrast to [`awsx.ecr.Image`](/registry/packages/awsx/api-docs/ecr/image/), this resource does not require to build the image, but can be used to push an existing image to an ECR repository. The image will be pushed whenever the source image changes or is updated.
//
// ## Example Usage
// ### Pushing an image to an ECR repository
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-awsx/sdk/v3/go/awsx/ecr"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			repository, err := ecr.NewRepository(ctx, "repository", &ecr.RepositoryArgs{
//				ForceDelete: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//
//			registryImage, err := ecr.NewRegistryImage(ctx, "registryImage", &ecr.RegistryImageArgs{
//				RepositoryUrl: repository.Url,
//				SourceImage:   pulumi.String("my-awesome-image:v1.0.0"),
//			})
//			if err != nil {
//				return err
//			}
//
//			return nil
//		})
//	}
//
// ```
type RegistryImage struct {
	pulumi.ResourceState

	// The underlying RegistryImage resource.
	Image docker.RegistryImageOutput `pulumi:"image"`
}

// NewRegistryImage registers a new resource with the given unique name, arguments, and options.
func NewRegistryImage(ctx *pulumi.Context,
	name string, args *RegistryImageArgs, opts ...pulumi.ResourceOption) (*RegistryImage, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.RepositoryUrl == nil {
		return nil, errors.New("invalid value for required argument 'RepositoryUrl'")
	}
	if args.SourceImage == nil {
		return nil, errors.New("invalid value for required argument 'SourceImage'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RegistryImage
	err := ctx.RegisterRemoteComponentResource("awsx:ecr:RegistryImage", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type registryImageArgs struct {
	// If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`
	InsecureSkipVerify *bool `pulumi:"insecureSkipVerify"`
	// If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`
	KeepRemotely *bool `pulumi:"keepRemotely"`
	// The URL of the repository (in the form aws_account_id.dkr.ecr.region.amazonaws.com/repositoryName).
	RepositoryUrl string `pulumi:"repositoryUrl"`
	// The source image to push to the registry.
	SourceImage string `pulumi:"sourceImage"`
	// The tag to use for the pushed image. If not provided, it defaults to `latest`.
	Tag *string `pulumi:"tag"`
	// A map of arbitrary strings that, when changed, will force the `docker.RegistryImage` resource to be replaced. This can be used to repush a local image
	Triggers map[string]string `pulumi:"triggers"`
}

// The set of arguments for constructing a RegistryImage resource.
type RegistryImageArgs struct {
	// If `true`, the verification of TLS certificates of the server/registry is disabled. Defaults to `false`
	InsecureSkipVerify pulumi.BoolPtrInput
	// If true, then the Docker image won't be deleted on destroy operation. If this is false, it will delete the image from the docker registry on destroy operation. Defaults to `false`
	KeepRemotely pulumi.BoolPtrInput
	// The URL of the repository (in the form aws_account_id.dkr.ecr.region.amazonaws.com/repositoryName).
	RepositoryUrl pulumi.StringInput
	// The source image to push to the registry.
	SourceImage pulumi.StringInput
	// The tag to use for the pushed image. If not provided, it defaults to `latest`.
	Tag pulumi.StringPtrInput
	// A map of arbitrary strings that, when changed, will force the `docker.RegistryImage` resource to be replaced. This can be used to repush a local image
	Triggers pulumi.StringMapInput
}

func (RegistryImageArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*registryImageArgs)(nil)).Elem()
}

type RegistryImageInput interface {
	pulumi.Input

	ToRegistryImageOutput() RegistryImageOutput
	ToRegistryImageOutputWithContext(ctx context.Context) RegistryImageOutput
}

func (*RegistryImage) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryImage)(nil)).Elem()
}

func (i *RegistryImage) ToRegistryImageOutput() RegistryImageOutput {
	return i.ToRegistryImageOutputWithContext(context.Background())
}

func (i *RegistryImage) ToRegistryImageOutputWithContext(ctx context.Context) RegistryImageOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryImageOutput)
}

// RegistryImageArrayInput is an input type that accepts RegistryImageArray and RegistryImageArrayOutput values.
// You can construct a concrete instance of `RegistryImageArrayInput` via:
//
//	RegistryImageArray{ RegistryImageArgs{...} }
type RegistryImageArrayInput interface {
	pulumi.Input

	ToRegistryImageArrayOutput() RegistryImageArrayOutput
	ToRegistryImageArrayOutputWithContext(context.Context) RegistryImageArrayOutput
}

type RegistryImageArray []RegistryImageInput

func (RegistryImageArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegistryImage)(nil)).Elem()
}

func (i RegistryImageArray) ToRegistryImageArrayOutput() RegistryImageArrayOutput {
	return i.ToRegistryImageArrayOutputWithContext(context.Background())
}

func (i RegistryImageArray) ToRegistryImageArrayOutputWithContext(ctx context.Context) RegistryImageArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryImageArrayOutput)
}

// RegistryImageMapInput is an input type that accepts RegistryImageMap and RegistryImageMapOutput values.
// You can construct a concrete instance of `RegistryImageMapInput` via:
//
//	RegistryImageMap{ "key": RegistryImageArgs{...} }
type RegistryImageMapInput interface {
	pulumi.Input

	ToRegistryImageMapOutput() RegistryImageMapOutput
	ToRegistryImageMapOutputWithContext(context.Context) RegistryImageMapOutput
}

type RegistryImageMap map[string]RegistryImageInput

func (RegistryImageMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegistryImage)(nil)).Elem()
}

func (i RegistryImageMap) ToRegistryImageMapOutput() RegistryImageMapOutput {
	return i.ToRegistryImageMapOutputWithContext(context.Background())
}

func (i RegistryImageMap) ToRegistryImageMapOutputWithContext(ctx context.Context) RegistryImageMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RegistryImageMapOutput)
}

type RegistryImageOutput struct{ *pulumi.OutputState }

func (RegistryImageOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RegistryImage)(nil)).Elem()
}

func (o RegistryImageOutput) ToRegistryImageOutput() RegistryImageOutput {
	return o
}

func (o RegistryImageOutput) ToRegistryImageOutputWithContext(ctx context.Context) RegistryImageOutput {
	return o
}

// The underlying RegistryImage resource.
func (o RegistryImageOutput) Image() docker.RegistryImageOutput {
	return o.ApplyT(func(v *RegistryImage) docker.RegistryImageOutput { return v.Image }).(docker.RegistryImageOutput)
}

type RegistryImageArrayOutput struct{ *pulumi.OutputState }

func (RegistryImageArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RegistryImage)(nil)).Elem()
}

func (o RegistryImageArrayOutput) ToRegistryImageArrayOutput() RegistryImageArrayOutput {
	return o
}

func (o RegistryImageArrayOutput) ToRegistryImageArrayOutputWithContext(ctx context.Context) RegistryImageArrayOutput {
	return o
}

func (o RegistryImageArrayOutput) Index(i pulumi.IntInput) RegistryImageOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RegistryImage {
		return vs[0].([]*RegistryImage)[vs[1].(int)]
	}).(RegistryImageOutput)
}

type RegistryImageMapOutput struct{ *pulumi.OutputState }

func (RegistryImageMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RegistryImage)(nil)).Elem()
}

func (o RegistryImageMapOutput) ToRegistryImageMapOutput() RegistryImageMapOutput {
	return o
}

func (o RegistryImageMapOutput) ToRegistryImageMapOutputWithContext(ctx context.Context) RegistryImageMapOutput {
	return o
}

func (o RegistryImageMapOutput) MapIndex(k pulumi.StringInput) RegistryImageOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RegistryImage {
		return vs[0].(map[string]*RegistryImage)[vs[1].(string)]
	}).(RegistryImageOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryImageInput)(nil)).Elem(), &RegistryImage{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryImageArrayInput)(nil)).Elem(), RegistryImageArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RegistryImageMapInput)(nil)).Elem(), RegistryImageMap{})
	pulumi.RegisterOutputType(RegistryImageOutput{})
	pulumi.RegisterOutputType(RegistryImageArrayOutput{})
	pulumi.RegisterOutputType(RegistryImageMapOutput{})
}
