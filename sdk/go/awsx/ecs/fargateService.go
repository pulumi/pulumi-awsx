// Code generated by pulumi-gen-awsx DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ecs

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-aws/sdk/v6/go/aws/ecs"
	"github.com/pulumi/pulumi-awsx/sdk/v2/go/awsx/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Create an ECS Service resource for Fargate with the given unique name, arguments, and options.
// Creates Task definition if `taskDefinitionArgs` is specified.
type FargateService struct {
	pulumi.ResourceState

	// Underlying ECS Service resource
	Service ecs.ServiceOutput `pulumi:"service"`
	// Underlying Fargate component resource if created from args
	TaskDefinition ecs.TaskDefinitionOutput `pulumi:"taskDefinition"`
}

// NewFargateService registers a new resource with the given unique name, arguments, and options.
func NewFargateService(ctx *pulumi.Context,
	name string, args *FargateServiceArgs, opts ...pulumi.ResourceOption) (*FargateService, error) {
	if args == nil {
		args = &FargateServiceArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource FargateService
	err := ctx.RegisterRemoteComponentResource("awsx:ecs:FargateService", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

type fargateServiceArgs struct {
	// Information about the CloudWatch alarms. See below.
	Alarms *ecs.ServiceAlarms `pulumi:"alarms"`
	// Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
	AssignPublicIp *bool `pulumi:"assignPublicIp"`
	// ARN of an ECS cluster.
	Cluster *string `pulumi:"cluster"`
	// If `true`, this provider will not wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`.
	ContinueBeforeSteadyState *bool `pulumi:"continueBeforeSteadyState"`
	// Configuration block for deployment circuit breaker. See below.
	DeploymentCircuitBreaker *ecs.ServiceDeploymentCircuitBreaker `pulumi:"deploymentCircuitBreaker"`
	// Configuration block for deployment controller configuration. See below.
	DeploymentController *ecs.ServiceDeploymentController `pulumi:"deploymentController"`
	// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.
	DeploymentMaximumPercent *int `pulumi:"deploymentMaximumPercent"`
	// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
	DeploymentMinimumHealthyPercent *int `pulumi:"deploymentMinimumHealthyPercent"`
	// Number of instances of the task definition to place and keep running. Defaults to 1. Do not specify if using the `DAEMON` scheduling strategy.
	DesiredCount *int `pulumi:"desiredCount"`
	// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
	EnableEcsManagedTags *bool `pulumi:"enableEcsManagedTags"`
	// Specifies whether to enable Amazon ECS Exec for the tasks within the service.
	EnableExecuteCommand *bool `pulumi:"enableExecuteCommand"`
	// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., `myimage:latest`), roll Fargate tasks onto a newer platform version, or immediately deploy `ordered_placement_strategy` and `placement_constraints` updates.
	ForceNewDeployment *bool `pulumi:"forceNewDeployment"`
	// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
	HealthCheckGracePeriodSeconds *int `pulumi:"healthCheckGracePeriodSeconds"`
	// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
	IamRole *string `pulumi:"iamRole"`
	// Configuration block for load balancers. See below.
	LoadBalancers []ecs.ServiceLoadBalancer `pulumi:"loadBalancers"`
	// Name of the service (up to 255 letters, numbers, hyphens, and underscores)
	//
	// The following arguments are optional:
	Name *string `pulumi:"name"`
	// Network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
	NetworkConfiguration *ecs.ServiceNetworkConfiguration `pulumi:"networkConfiguration"`
	// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. Maximum number of `placement_constraints` is `10`. See below.
	PlacementConstraints []ecs.ServicePlacementConstraint `pulumi:"placementConstraints"`
	// Platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
	PlatformVersion *string `pulumi:"platformVersion"`
	// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.
	PropagateTags *string `pulumi:"propagateTags"`
	// Scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Tasks using the Fargate launch type or the `CODE_DEPLOY` or `EXTERNAL` deployment controller types don't support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html).
	SchedulingStrategy *string `pulumi:"schedulingStrategy"`
	// The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
	ServiceConnectConfiguration *ecs.ServiceServiceConnectConfiguration `pulumi:"serviceConnectConfiguration"`
	// Service discovery registries for the service. The maximum number of `service_registries` blocks is `1`. See below.
	ServiceRegistries *ecs.ServiceServiceRegistries `pulumi:"serviceRegistries"`
	// Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags map[string]string `pulumi:"tags"`
	// Family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided.
	TaskDefinition *string `pulumi:"taskDefinition"`
	// The args of task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided.
	TaskDefinitionArgs *FargateServiceTaskDefinition `pulumi:"taskDefinitionArgs"`
	// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with `plantimestamp()`. See example above.
	Triggers map[string]string `pulumi:"triggers"`
}

// The set of arguments for constructing a FargateService resource.
type FargateServiceArgs struct {
	// Information about the CloudWatch alarms. See below.
	Alarms ecs.ServiceAlarmsPtrInput
	// Assign a public IP address to the ENI (Fargate launch type only). Valid values are `true` or `false`. Default `false`.
	AssignPublicIp pulumi.BoolPtrInput
	// ARN of an ECS cluster.
	Cluster pulumi.StringPtrInput
	// If `true`, this provider will not wait for the service to reach a steady state (like [`aws ecs wait services-stable`](https://docs.aws.amazon.com/cli/latest/reference/ecs/wait/services-stable.html)) before continuing. Default `false`.
	ContinueBeforeSteadyState pulumi.BoolPtrInput
	// Configuration block for deployment circuit breaker. See below.
	DeploymentCircuitBreaker ecs.ServiceDeploymentCircuitBreakerPtrInput
	// Configuration block for deployment controller configuration. See below.
	DeploymentController ecs.ServiceDeploymentControllerPtrInput
	// Upper limit (as a percentage of the service's desiredCount) of the number of running tasks that can be running in a service during a deployment. Not valid when using the `DAEMON` scheduling strategy.
	DeploymentMaximumPercent pulumi.IntPtrInput
	// Lower limit (as a percentage of the service's desiredCount) of the number of running tasks that must remain running and healthy in a service during a deployment.
	DeploymentMinimumHealthyPercent pulumi.IntPtrInput
	// Number of instances of the task definition to place and keep running. Defaults to 1. Do not specify if using the `DAEMON` scheduling strategy.
	DesiredCount pulumi.IntPtrInput
	// Specifies whether to enable Amazon ECS managed tags for the tasks within the service.
	EnableEcsManagedTags pulumi.BoolPtrInput
	// Specifies whether to enable Amazon ECS Exec for the tasks within the service.
	EnableExecuteCommand pulumi.BoolPtrInput
	// Enable to force a new task deployment of the service. This can be used to update tasks to use a newer Docker image with same image/tag combination (e.g., `myimage:latest`), roll Fargate tasks onto a newer platform version, or immediately deploy `ordered_placement_strategy` and `placement_constraints` updates.
	ForceNewDeployment pulumi.BoolPtrInput
	// Seconds to ignore failing load balancer health checks on newly instantiated tasks to prevent premature shutdown, up to 2147483647. Only valid for services configured to use load balancers.
	HealthCheckGracePeriodSeconds pulumi.IntPtrInput
	// ARN of the IAM role that allows Amazon ECS to make calls to your load balancer on your behalf. This parameter is required if you are using a load balancer with your service, but only if your task definition does not use the `awsvpc` network mode. If using `awsvpc` network mode, do not specify this role. If your account has already created the Amazon ECS service-linked role, that role is used by default for your service unless you specify a role here.
	IamRole pulumi.StringPtrInput
	// Configuration block for load balancers. See below.
	LoadBalancers ecs.ServiceLoadBalancerArrayInput
	// Name of the service (up to 255 letters, numbers, hyphens, and underscores)
	//
	// The following arguments are optional:
	Name pulumi.StringPtrInput
	// Network configuration for the service. This parameter is required for task definitions that use the `awsvpc` network mode to receive their own Elastic Network Interface, and it is not supported for other network modes. See below.
	NetworkConfiguration ecs.ServiceNetworkConfigurationPtrInput
	// Rules that are taken into consideration during task placement. Updates to this configuration will take effect next task deployment unless `force_new_deployment` is enabled. Maximum number of `placement_constraints` is `10`. See below.
	PlacementConstraints ecs.ServicePlacementConstraintArrayInput
	// Platform version on which to run your service. Only applicable for `launch_type` set to `FARGATE`. Defaults to `LATEST`. More information about Fargate platform versions can be found in the [AWS ECS User Guide](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html).
	PlatformVersion pulumi.StringPtrInput
	// Specifies whether to propagate the tags from the task definition or the service to the tasks. The valid values are `SERVICE` and `TASK_DEFINITION`.
	PropagateTags pulumi.StringPtrInput
	// Scheduling strategy to use for the service. The valid values are `REPLICA` and `DAEMON`. Defaults to `REPLICA`. Note that [*Tasks using the Fargate launch type or the `CODE_DEPLOY` or `EXTERNAL` deployment controller types don't support the `DAEMON` scheduling strategy*](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html).
	SchedulingStrategy pulumi.StringPtrInput
	// The ECS Service Connect configuration for this service to discover and connect to services, and be discovered by, and connected from, other services within a namespace. See below.
	ServiceConnectConfiguration ecs.ServiceServiceConnectConfigurationPtrInput
	// Service discovery registries for the service. The maximum number of `service_registries` blocks is `1`. See below.
	ServiceRegistries ecs.ServiceServiceRegistriesPtrInput
	// Key-value map of resource tags. If configured with a provider `default_tags` configuration block present, tags with matching keys will overwrite those defined at the provider-level.
	Tags pulumi.StringMapInput
	// Family and revision (`family:revision`) or full ARN of the task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided.
	TaskDefinition pulumi.StringPtrInput
	// The args of task definition that you want to run in your service. Either [taskDefinition] or [taskDefinitionArgs] must be provided.
	TaskDefinitionArgs *FargateServiceTaskDefinitionArgs
	// Map of arbitrary keys and values that, when changed, will trigger an in-place update (redeployment). Useful with `plantimestamp()`. See example above.
	Triggers pulumi.StringMapInput
}

func (FargateServiceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*fargateServiceArgs)(nil)).Elem()
}

type FargateServiceInput interface {
	pulumi.Input

	ToFargateServiceOutput() FargateServiceOutput
	ToFargateServiceOutputWithContext(ctx context.Context) FargateServiceOutput
}

func (*FargateService) ElementType() reflect.Type {
	return reflect.TypeOf((**FargateService)(nil)).Elem()
}

func (i *FargateService) ToFargateServiceOutput() FargateServiceOutput {
	return i.ToFargateServiceOutputWithContext(context.Background())
}

func (i *FargateService) ToFargateServiceOutputWithContext(ctx context.Context) FargateServiceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateServiceOutput)
}

// FargateServiceArrayInput is an input type that accepts FargateServiceArray and FargateServiceArrayOutput values.
// You can construct a concrete instance of `FargateServiceArrayInput` via:
//
//	FargateServiceArray{ FargateServiceArgs{...} }
type FargateServiceArrayInput interface {
	pulumi.Input

	ToFargateServiceArrayOutput() FargateServiceArrayOutput
	ToFargateServiceArrayOutputWithContext(context.Context) FargateServiceArrayOutput
}

type FargateServiceArray []FargateServiceInput

func (FargateServiceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FargateService)(nil)).Elem()
}

func (i FargateServiceArray) ToFargateServiceArrayOutput() FargateServiceArrayOutput {
	return i.ToFargateServiceArrayOutputWithContext(context.Background())
}

func (i FargateServiceArray) ToFargateServiceArrayOutputWithContext(ctx context.Context) FargateServiceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateServiceArrayOutput)
}

// FargateServiceMapInput is an input type that accepts FargateServiceMap and FargateServiceMapOutput values.
// You can construct a concrete instance of `FargateServiceMapInput` via:
//
//	FargateServiceMap{ "key": FargateServiceArgs{...} }
type FargateServiceMapInput interface {
	pulumi.Input

	ToFargateServiceMapOutput() FargateServiceMapOutput
	ToFargateServiceMapOutputWithContext(context.Context) FargateServiceMapOutput
}

type FargateServiceMap map[string]FargateServiceInput

func (FargateServiceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FargateService)(nil)).Elem()
}

func (i FargateServiceMap) ToFargateServiceMapOutput() FargateServiceMapOutput {
	return i.ToFargateServiceMapOutputWithContext(context.Background())
}

func (i FargateServiceMap) ToFargateServiceMapOutputWithContext(ctx context.Context) FargateServiceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FargateServiceMapOutput)
}

type FargateServiceOutput struct{ *pulumi.OutputState }

func (FargateServiceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**FargateService)(nil)).Elem()
}

func (o FargateServiceOutput) ToFargateServiceOutput() FargateServiceOutput {
	return o
}

func (o FargateServiceOutput) ToFargateServiceOutputWithContext(ctx context.Context) FargateServiceOutput {
	return o
}

// Underlying ECS Service resource
func (o FargateServiceOutput) Service() ecs.ServiceOutput {
	return o.ApplyT(func(v *FargateService) ecs.ServiceOutput { return v.Service }).(ecs.ServiceOutput)
}

// Underlying Fargate component resource if created from args
func (o FargateServiceOutput) TaskDefinition() ecs.TaskDefinitionOutput {
	return o.ApplyT(func(v *FargateService) ecs.TaskDefinitionOutput { return v.TaskDefinition }).(ecs.TaskDefinitionOutput)
}

type FargateServiceArrayOutput struct{ *pulumi.OutputState }

func (FargateServiceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*FargateService)(nil)).Elem()
}

func (o FargateServiceArrayOutput) ToFargateServiceArrayOutput() FargateServiceArrayOutput {
	return o
}

func (o FargateServiceArrayOutput) ToFargateServiceArrayOutputWithContext(ctx context.Context) FargateServiceArrayOutput {
	return o
}

func (o FargateServiceArrayOutput) Index(i pulumi.IntInput) FargateServiceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *FargateService {
		return vs[0].([]*FargateService)[vs[1].(int)]
	}).(FargateServiceOutput)
}

type FargateServiceMapOutput struct{ *pulumi.OutputState }

func (FargateServiceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*FargateService)(nil)).Elem()
}

func (o FargateServiceMapOutput) ToFargateServiceMapOutput() FargateServiceMapOutput {
	return o
}

func (o FargateServiceMapOutput) ToFargateServiceMapOutputWithContext(ctx context.Context) FargateServiceMapOutput {
	return o
}

func (o FargateServiceMapOutput) MapIndex(k pulumi.StringInput) FargateServiceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *FargateService {
		return vs[0].(map[string]*FargateService)[vs[1].(string)]
	}).(FargateServiceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FargateServiceInput)(nil)).Elem(), &FargateService{})
	pulumi.RegisterInputType(reflect.TypeOf((*FargateServiceArrayInput)(nil)).Elem(), FargateServiceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FargateServiceMapInput)(nil)).Elem(), FargateServiceMap{})
	pulumi.RegisterOutputType(FargateServiceOutput{})
	pulumi.RegisterOutputType(FargateServiceArrayOutput{})
	pulumi.RegisterOutputType(FargateServiceMapOutput{})
}
